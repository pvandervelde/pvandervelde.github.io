
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Mind vortex</title>
        <meta name="description" content="Welcome!" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link type="application/rss+xml" rel="alternate" title="Mind vortex" href="/feed.rss" />
        <link type="application/atom+xml" rel="alternate" title="Mind vortex" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/normalize.css" rel="stylesheet" />
        <link href="/assets/css/h5bp.css" rel="stylesheet">
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
        <link href="/assets/css/override.css" rel="stylesheet" />
        <link href="/assets/css/github.css" rel="stylesheet" type="text/css">

        <script src="https://fred-wang.github.io/TeXZilla/TeXZilla-min.js"></script>
        <script src="https://fred-wang.github.io/TeXZilla/examples/customElement.js"></script>
        <link href="https://fred-wang.github.io/MathFonts/Asana/mathfonts.css" rel="stylesheet" />

        <meta name="application-name" content="Mind vortex" />
        <meta name="msapplication-tooltip" content="Mind vortex" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Mind vortex" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://www.petrikvandervelde.nl/" />
        <!-- TODO: More social graph meta tags -->

        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>
        <script src="/assets/js/highlight.pack.js"></script>
        <script src="/assets/js/clean-blog.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="/assets/js/html5shiv.js"></script>
                <script src="/assets/js/respond.min.js"></script>
        <![endif]-->

        <!-- Our scripts -->
<script src="/assets/js/script.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DV643VJGFT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DV643VJGFT');
</script>


    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->
        <div id="header" class="container">
            <div id="logo">
                <h1><a href="/">Mind vortex</a></h1>
            </div>
            <div id="menu">
                <ul>
                            <!-- Pages -->
        <!-- BlogPosts -->
        <!-- Tags -->
        <!-- TagIndex -->
        <!-- BlogArchive -->
        <!-- Index -->
    <!-- Context.Documents['Pages'] -->
        <!-- 404 Not Found - False - /404 -->
        <!-- About - True - /about -->
        <!-- Projects - True - /projects -->
        <!-- Robotics - False - /projects/robotics -->
        <!-- Scuttle - False - /projects/scuttle -->
        <!-- Zinger - False - /projects/zinger -->
            <li class="active" >
                Home
            </li>
            <li class="inactive" >
                <a href="/projects">Projects</a>
            </li>
            <li class="inactive" >
                <a href="/posts">Archive</a>
            </li>
            <li class="inactive" >
                <a href="/tags">Tags</a>
            </li>
            <li class="inactive" >
                <a href="/about">About</a>
            </li>

                </ul>
            </div>
        </div>

        <div id="page" class="container">
            <div id="sidebar">
                <div id="sbox1">
                    <h2>Patrick van der Velde</h2>

<p>
    <img src="https://www.gravatar.com/avatar/9bc8b3ff385cd14f2b12138c97729df2?s=160"
        alt="Gravatar for Patrick van der Velde">
</p>
<p>
    I am a senior lead software engineer who is living, working and playing in New Zealand.
    Developer of the <a href="/tags/Zinger">Zinger robot</a>, contributor on the
    <a href="/tags/Scuttle">Scuttle project</a>.

    In my spare time wood worker, rock climber, gardner.
</p>
<p>
    <a href="/about.html">More ...</a>
</p>

                </div>
                <div id="sbox2">
                    <h2>Recent</h2>
                    <ul class="list-unstyled">
                            <li><a href="/posts/Robotics-making-urdf-models">Robotics - Making URDF models</a></li>
                            <li><a href="/posts/Swerve-motion-profiles">Swerve drive - Motion profiles</a></li>
                            <li><a href="/posts/Swerve-drive-control-animations">Swerve drive - Movement animations</a></li>
                            <li><a href="/posts/Swerve-drive-body-focussed-control">Swerve drive - Better movement by controlling the body motions</a></li>
                            <li><a href="/posts/Swerve-drive-kinematics-verification">Swerve drive - Verification of the kinematics solution</a></li>
                            <li><a href="/posts/Swerve-drive-kinematics-simulation">Swerve drive - Kinematics simulation</a></li>
                            <li><a href="/posts/Swerve-drive-introduction">Swerve drive - Moving a robot in all directions, mostly</a></li>
                            <li><a href="/posts/Robotics-fixing-scuttles-encoder">Starting robotics - Fixing the wheel encoders</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-electronics">Starting robotics - Building a bumper for scuttle. The electronics</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a></li>
                    </ul>
                </div>
                <div id="sbox3">
                    <h2>Tags</h2>
                    <div>
                        <ul class="list-unstyled">
                                <li>
                                    <a role="button" href="/tags/Robotics" class="btn btn-default btn-sm"> Robotics (15)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Sherlock" class="btn btn-default btn-sm"> Sherlock (13)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/nBuildKit" class="btn btn-default btn-sm"> nBuildKit (12)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Software-development-pipeline" class="btn btn-default btn-sm"> Software development pipeline (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/DevOps" class="btn btn-default btn-sm"> DevOps (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Delivering-software" class="btn btn-default btn-sm"> Delivering software (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/PG2" class="btn btn-default btn-sm"> PG2 (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Paragliding" class="btn btn-default btn-sm"> Paragliding (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Zinger" class="btn btn-default btn-sm"> Zinger (7)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Blog" class="btn btn-default btn-sm"> Blog (7)</a>
                                </li>
                        </ul>
                    </div>
                    <br />
                    <ul class="pager">
                        <li class="next">
                            <a href="/tags">View All Tags &rarr;</a>
                        </li>
                    </ul>
                </div>
            </div>

            <div id="content">

        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-making-urdf-models">Robotics - Making URDF models</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Saturday, December 23, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Gazebo" class="btn btn-default btn-xs tag-no-wrap">Gazebo</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS2" class="btn btn-default btn-xs tag-no-wrap">ROS2</a>
                        <a id="post-category" role="button" href="/tags/Simulation" class="btn btn-default btn-xs tag-no-wrap">Simulation</a>
                        <a id="post-category" role="button" href="/tags/Zinger" class="btn btn-default btn-xs tag-no-wrap">Zinger</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In a <a href="posts/Robotics-driving-scuttle-with-ros-gazebo-simulation">previous post</a> I talked about simulating
the <a href="https://scuttlerobot.org">SCUTTLE robot</a> using ROS and Gazebo.  I used Gazebo to
simulate the SCUTTLE robot so that I could learn more about ROS without needing to involve a real
robot with all the setup and complications that come with that. Additionally when I was designing the
<a href="posts/Robotics-a-bumper-for-scuttle-overview">bump sensor</a> for SCUTTLE using the simulation allowed
me to reduce the feedback time compared to testing the design on a physical robot. This speeds up
the design iteration process and allowed me to quickly and verify the design and the code. In the end
you always need to do the final testing on a real robot, but by using simulation you can quickly
iterate to a solution that will most likely work without major issues.</p>
<p>In order to progress my <a href="posts/Swerve-drive-introduction">swerve drive robot</a> I wanted to verify that
the control algorithms that I had developed would work for an actual robot. Ideally before spending
money on the hardware. So I decided to use Gazebo to run some simulations that would enable me to
verify the control algorithm.</p>
<p>The first step in using Gazebo is to create a model of the robot and its surrounding environment.
Gazebo natively uses the <a href="http://sdformat.org/">SDF</a> format to define both the robot and the
environment. However if you want ROS nodes to be able to understand the geometry definition of your
robot you need to use the <a href="http://wiki.ros.org/urdf">URDF</a> format. This is important for instance
if you want to make use of the <a href="https://docs.ros.org/en/humble/Concepts/Intermediate/About-Tf2.html">tf2</a>
library to transform between different coordinate frames then your ROS nodes will have to have the
<a href="https://github.com/ros/robot_state_publisher/tree/humble">geometry of the robot</a> available.</p>
<p>There are different ways to create an URDF model. One way is to draw the robot in a CAD program
and then use a plugin to export the model to an URDF file. This is a relatively quick approach, it
takes time to create the robot in the CAD program but then the export is very quick. The drawback
of this method is that the resulting URDF file is not very clean which makes it harder to edit
later on. Additionally the CAD software will use meshes for both the visual geometry and the collision
geometry. As discussed below this can lead to issues with the collision detection.
Another way is to create the URDF manually. This approach is slower than the CAD export approach,
however it results in a much more minimal and clean URDF file. This makes editing the file at a
later stage a lot easier. Additionally manually creating the URDF file give you a better understanding
of the URDF format and how it works. In the end the model for my swerve drive robot is very simple,
consisting of a body, four wheels, the steering and drive controllers and the sensors. So I decided
to create the URDF file manually. The images below show the resulting model in RViz. The model consists
of the robot body in orange, the four drive modules in blue and black, and the lidar unit in red.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/swerve/rviz_zinger_side_view.png" target="_blank">
    <img
        alt="The Zinger swerve robot as seen from the side in RViz."
        src="/assets/images/robotics/swerve/rviz_zinger_side_view.png"
        width="375"
        height="186"/>
  </a>
  <figcaption>
    The Zinger swerve robot as seen from the side in RViz.
  </figcaption>
</figure>
<figure style="float:right">
  <a href="/assets/images/robotics/swerve/rviz_zinger_front_top_view.png" target="_blank">
    <img
        alt="The Zinger swerve robot as seen from the front and top in RViz."
        src="/assets/images/robotics/swerve/rviz_zinger_front_top_view.png"
        width="375"
        height="260"/>
  </a>
  <figcaption>
    The Zinger swerve robot as seen from the front and top in RViz.
  </figcaption>
</figure>
<p>The URDF model describes the different parts of the robot relative to each other. The robot parts
consist of the physical parts of the robot, the sensors and the actuators. The physical parts, e.g.
the wheels or the body, are described using <a href="https://wiki.ros.org/urdf/XML/link">links</a>. The links
are connected to each other using <a href="https://wiki.ros.org/urdf/XML/joint">joints</a>. Joints allow the
links to move relative to each other. Joints can be fixed, e.g. when two structural parts are statically
connected to each other, or they can be movable. If a joint is movable then be one of:</p>
<ul>
<li>A revolute joint, which allows the two links to rotate relative to each other around a single axis.</li>
<li>A continuous joint, which is similar to a revolute joint but allows the joint to rotate continuously
without any limits.</li>
<li>A prismatic joint, which allows the two links to move relative to each other along a single axis.</li>
<li>A floating joint, which allows the two links to move relative to each other in 6 degrees of freedom.</li>
<li>A planar joint, which allows the two links to move relative to each other in 3 degrees of freedom
in a plane.</li>
</ul>
<p>In the URDF file each link defines the visual geometry, the collision geometry and the inertial
properties for that link. The visual and collision geometry can be defined either by a primitive
(box, cylinder or sphere) or a triangle mesh. It is recommended to use simple primitives for the
collision geometry since these make the collision calculations faster and more stable. If you use a
triangle mesh for the collision geometry then you can get issues with the collision detection. This
can lead to the robot moving around when it shouldn't. For instance when the wheel of the robot is
modelled as a triangle mesh then the collision calculation between the wheel and the ground may not
be numerically stable which leads to undesired movement of the robot. The current version of the SCUTTLE
URDF has this problem as is shown in the video below. In a future post I'll describe how to fix this.</p>
<iframe
    style="float:left"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/kyMvlBAQGoE"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>Using meshes for the visual geometry is fine as this geometry is only used for the visual
representation of the robot. Note that the meshes should be relatively simple as well since Gazebo
will have to render the meshes in real time which is expensive if the mesh consists of a large number
of vertices and triangles.</p>
<p>I normally start by defining a link that represents the <a href="https://www.ros.org/reps/rep-0120.html#base-footprint">footprint</a>
of the robot on the ground, called <code>base_footprint</code>. This link doesn't define any geometry, it is
only used to define the origin of the robot. When navigation is configured it will be referencing
this footprint link. The next link that is defined is the <code>base_link</code>. This link is generally defined
to be the &lsquo;middle&rsquo; of the robot frame and it forms the parent for all the other robot parts.</p>
<p>The next step is to define the rest of the links and joints. For the swerve drive robot I have four
drive modules, each consisting of a wheel and a steering motor. The wheel is connected to the steering
motor using a continuous joint. The steering motor is connected to the base link using another continuous
joint. Because the four modules are all the same I use the <a href="http://wiki.ros.org/xacro">xacro</a> format.
This allows me to define <a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/urdf/macros.xacro">a single module as a template</a>
and then use that template to create the four modules. The benefit of this is that it makes the URDF
file easier to edit and a lot smaller and easier to read.</p>
<p>To add sensors you need to add two pieces of information, the information about the sensor body and,
if you are using gazebo, the information about the sensors behaviour. The former consist of the
visual and collision geometry of the sensor. The latter consists of the sensor plugin that is used
to simulate the sensor. For the swerve drive robot I have two sensors, a lidar and an IMU. The
lidar is used to provide a point cloud for the different <a href="https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping">SLAM</a>
algorithms which allow the robot to determine where it is and what the environment looks like. The
<a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/urdf/gazebo.xacro#L90">Gazebo configuration</a>
is based on the use of a <a href="https://www.slamtec.com/en/Lidar/A1">rplidar</a> sensor. The IMU is experimental
and currently not used in any of the control algorithms. The
<a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/urdf/gazebo.xacro#L26">Gazebo configuration</a>
is based on a generic IMU.</p>
<p>The last part of the URDF file is the definition of the <a href="https://ros-controls.github.io/control.ros.org/">ROS2 control</a>
interface. This interface allows you to control the different joints of the robot using ROS2 topics.
The ROS2 control configuration consists of the <a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/urdf/base.xacro#L205">general configuration</a>
and the configuration specific to <a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/urdf/gazebo.xacro#L148">Gazebo</a>.
It should be noted that the Gazebo specific configuration depends on linking to the correct control
plugin for Gazebo. In my case, using <a href="https://docs.ros.org/en/humble/">ROS2 Humble</a>,
and <a href="https://gazebosim.org/docs/fortress/install">Gazebo Ignition Fortress</a>, I need to use the
<code>ign_ros2_control-system</code> plugin with the <code>ign_ros2_control::IgnitionROS2ControlPlugin</code> entrypoint.
For other versions of ROS2 and Gazebo you may need to use a different plugin.</p>
<p>When you are using this information to create your URDF model there are a number of issues that you may
run into. The main ones I ran in to are:</p>
<ul>
<li>ROS2 control documentation is lacking in that it doesn't necessarily exist for the combination of
your version of ROS and Gazebo. That means you need to look at the source code to figure out the
names of the plugins and which controllers are available. For instance ROS2 control defines a
<a href="https://control.ros.org/humble/doc/ros2_controllers/joint_trajectory_controller/doc/userdoc.html">joint trajectory controller</a>.
This controller should be able to work with a velocity trajectory, i.e. a trajectory that defines
changes in velocity. However the current implementation of the controller doesn't support this. Additionally
the Gazebo plugin doesn't support all the controller types that are available in ROS2 control. To
find out which controllers actually work in Gazebo you need to search the source code of the Gazebo
control plugin.</li>
<li>In order to run ROS2 control you need to load the <a href="https://control.ros.org/humble/doc/ros2_control/controller_manager/doc/userdoc.html">controller manager</a>.
This component manages the lifecyle of the controllers. However when running in Gazebo you shouldn't
to load the controller manager as Gazebo loads one for you. If you do load the controller manager
then you will get an error message that the controller manager is already loaded. Also note that in
order to optionally load the controller when using the Python launch files you need to use the
<a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/launch/controllers.launch.py#L52">unless</a>
construct, not the Python <code>if .. then</code> approach. The latter doesn't work due to the delayed
evaluation of the launch file.</li>
<li>The start up order of the ROS2 control controllers relative to other ROS nodes is important. When
the controllers start they will try to get the joint and link descriptions from the
<a href="https://github.com/ros/robot_state_publisher/tree/humble"><code>robot state publisher</code></a>. This won't
be running until after the simulation starts. So you need to <a href="https://github.com/pvandervelde/zinger_description/blob/bb24b884f8bcc62c9c2e8f12bac431f4b62dea6f/launch/controllers.launch.py#L72">delay</a>
the start of the controllers until after the robot is loaded in Gazebo and the state publisher node
is running.</li>
<li>Unlike with ROS1 if you want your ROS2 nodes to get information from Gazebo, e.g. the simulation
time or the current position or velocity of a joint, then you need to set up a
<a href="https://github.com/pvandervelde/zinger_ignition/blob/5e71f841d1db557c3e62ff38291701ddc31a0d73/launch/ignition_bridge.launch.py#L19">ROS bridge</a>.
This is because Gazebo no longer connects to the ROS2 messaging system automatically. For my simulation
I bridged the following topics:
<ul>
<li><code>/clock</code> - The simulation time. This was bridged unidirectionally from Gazebo to ROS2 into the
<code>/clock</code> topic.</li>
<li><code>/cmd_vel</code> - The velocity commands for the robot. This was bridged bidirectionally between Gazebo
and ROS2.</li>
<li><code>/model/&lt;ROBOT_NAME&gt;/pose</code> and <code>/model/&lt;ROBOT_NAME&gt;/pose_static</code> - The position of the robot
in the simulation as seen by the simulation. This was bridged unidirectionally from Gazebo to
ROS2 into the <code>/ground_truth_pose</code> and <code>/ground_truth_pose_static</code> topics.</li>
<li><code>/model/&lt;ROBOT_NAME&gt;/tf</code> - The transformation between the different coordinate frames of the
robot as seen by the simulation. This was bridged unidirectionally from Gazebo to ROS2 into the
<code>/model/&lt;ROBOT_NAME&gt;/tf</code> topic.</li>
<li><code>/&lt;LIDAR_NAME&gt;/scan</code> and <code>/&lt;LIDAR_NAME&gt;/scan/points</code> - The point cloud from the lidar sensor.
These were bridged unidirectionally from Gazebo to ROS2 into the <code>/scan</code> and <code>/scan/points</code> topics.</li>
<li><code>/world/&lt;WORLD_NAME&gt;/model/&lt;MODEL_NAME&gt;/link/&lt;IMU_SENSOR_LINK_NAME&gt;/sensor/&lt;IMU_NAME&gt;/imu</code> - The
IMU data. This was bridged unidirectionally from Gazebo to ROS2 into the <code>/imu</code> topic.</li>
</ul>
</li>
</ul>
<p>Finally one issue  that applies specifically to ROS2 Humble and Gazebo Ignition has to do with the
fact that Gazebo Ignition was renamed back to Gazebo. This means that some of the plugins have been
renamed as well. So the information you find on the internet about the correct name of the plugin
may be out of date.</p>
<p>Once you have the URDF you need to get Gazebo to load it. This is done in two parts. First you need
to load the <code>robot state publisher</code> and provide it with the robot description (URDF). The code below
provides an example on how to achieve this.</p>
<pre><code class="language-python">def generate_launch_description():
    is_simulation = LaunchConfiguration(&quot;use_sim_time&quot;)
    use_fake_hardware = LaunchConfiguration(&quot;use_fake_hardware&quot;)
    fake_sensor_commands = LaunchConfiguration(&quot;fake_sensor_commands&quot;)

    robot_description_content = Command(
        [
            PathJoinSubstitution([FindExecutable(name=&quot;xacro&quot;)]),
            &quot; &quot;,
            PathJoinSubstitution([get_package_share_directory('zinger_description'), &quot;urdf&quot;, 'base.xacro']),
            &quot; &quot;,
            &quot;is_simulation:=&quot;,
            is_simulation,
             &quot; &quot;,
            &quot;use_fake_hardware:=&quot;,
            use_fake_hardware,
            &quot; &quot;,
            &quot;fake_sensor_commands:=&quot;,
            fake_sensor_commands,
        ]
    )
    robot_description = {&quot;robot_description&quot;: ParameterValue(robot_description_content, value_type=str)}

    # Takes the joint positions from the 'joint_state' topic and updates the position of the robot with tf2.
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='screen',
        parameters=[
            {'use_sim_time': LaunchConfiguration('use_sim_time')},
            robot_description,
        ],
    )

    ld = LaunchDescription(ARGUMENTS)
    ld.add_action(robot_state_publisher)
    return ld

</code></pre>
<p>Then you need to spawn the robot in Gazebo. Assuming you're using Gazebo Ignition then you can use
the <code>ros_ign_gazebo</code> package with the command line as shown below.</p>
<pre><code class="language-python">
    def generate_launch_description():
        spawn_robot = Node(
            package='ros_ign_gazebo',
            executable='create',
            arguments=[
                '-name', LaunchConfiguration('robot_name'),
                '-x', x,
                '-y', y,
                '-z', z,
                '-Y', yaw,
                '-topic', '/robot_description'],
            output='screen')

        ld = LaunchDescription(ARGUMENTS)
        ld.add_action(spawn_robot)

        return ld
</code></pre>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/fR47Y7p4mtQ"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>Once you have set this all up you should be able to run Gazebo and see your robot in the simulation.
At this point you can then control the robot using the ROS2 control interface by sending the
appropriate messages. For an example you can look at the <a href="https://github.com/pvandervelde/zinger_controller_test_nodes">test control library</a>
for the swerve robot. That should allow you to get the robot moving as shown in the video. In the video
two different control commands are given. One controls the motion of the steering actuators and makes
the wheels steer from left to right and back again on a timed loop. The other controls the motion of
the wheels, driving them forwards and then backwards, also on a timed loop. Obviously this is not
a good way to control the robot, but it does allow you to verify that you have correctly configured
all the parts of your robot for use in Gazebo.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-motion-profiles">Swerve drive - Motion profiles</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Monday, July 24, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
                        <a id="post-category" role="button" href="/tags/Zinger" class="btn btn-default btn-xs tag-no-wrap">Zinger</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In the last few posts I have described the simulations I did of a robot with a swerve drive. In
other words a robot with four wheels each of which is independently driven and steered. I did
simulations for the case where we specified movement commands <a href="https://youtu.be/LlyopmLMlZY">directly for the drive modules</a>
and one for the case where we specified movement commands for <a href="https://youtu.be/U6Z_meFKNrI">the robot body</a>
which were then translated in the appropriate movements for the drive modules.
One of the things you can see in both simulations is that the motions is quite &lsquo;jerky&rsquo;, i.e. with
sudden changes of velocity or acceleration. In real life this kind of change would be noticed by
humans as shocks which are <a href="https://en.wikipedia.org/wiki/Jerk_(physics)#Physiological_effects_and_human_perception">uncomfortable and can potentially cause injury</a>.
For the equipment, i.e. the robot parts, a jerky motion adds load which can cause failures. So for
both humans and equipment it is sensible to keep the 'jerkiness' as low as possible.</p>
<p>In order to achieve this we first need to understand what jerk actually is. Once we understand it
we can figure out ways to control it. Jerk is defined as the change of acceleration
with time, i.e the first time derivative of acceleration. So jerk vector as a function of time,
<la-tex>\vec{{j}}(t)</la-tex> can be defined as:</p>
<p>
  <la-tex class="block">
    \vec{j}(t) = \frac{d\vec{a}(t)}{dt} = \frac{d^{2}\vec{v}(t)}{dt^{2}} = \frac{d^{3}\vec{r}(t))}{dt^{3}}
  </la-tex>
</p>
<p>Where</p>
<ul>
<li><la-tex>t</la-tex> is time.</li>
<li><la-tex>\frac{{d}}{{dt}}</la-tex>, <la-tex>\frac{{d}}{{dt^{2}}}</la-tex>, <la-tex>\frac{{d}}{{dt^{3}}}</la-tex>
are the <a href="https://en.wikipedia.org/wiki/Time_derivative">first</a>, <a href="https://en.wikipedia.org/wiki/Second_derivative">second</a>
and <a href="https://en.wikipedia.org/wiki/Third_derivative">third</a> time derivatives.</li>
<li><la-tex>\vec{{a}}</la-tex> is the acceleration vector.</li>
<li><la-tex>\vec{{v}}</la-tex> is the velocity vector.</li>
<li><la-tex>\vec{{r}}</la-tex> is the position vector.</li>
</ul>
<p>From these equations we can for instance deduce that a linearly increasing acceleration is caused by
a constant jerk value. And a constant jerk value leads to a quadratic behaviour in the velocity. A
more interesting deduction is that an acceleration that changes from a linear increase to a constant
value means that there must be a discontinuous change in jerk. After all a linear increasing acceleration
is caused by a constant positive jerk, and a constant acceleration is achieved by a zero jerk. Where
these two acceleration profiles meet there must be a jump in jerk.</p>
<p>With that you can probably imagine what happens if the velocity has a change from a linearly increasing
value to a constant value. The acceleration drops from a positive constant value to zero. And the
jerk value displays spikes when the acceleration changes. For the linear motion profile this behaviour
is amplified as shown in the plot below. The change in position requires a constant value for velocity
which requires significant acceleration and jerk spikes at the start and end of the motion profile.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_linear_motion_profile.png" target="_blank">
    <img
        alt="Position, velocity, acceleration and jerk curves for the linear motion profile"
        src="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_linear_motion_profile.png"
        width="800"/>
  </a>
  <figcaption>Position, velocity, acceleration and jerk curves for the linear motion profile.</figcaption>
</figure>
<p>So in order to move a robot, or robot part, from one location to another in a way that the jerk
values stay manageable we need to control the velocity and acceleration across time. This is normally
done using a motion profile which describes how the velocity and acceleration change over time in
order to arrive at the new state at the desired point in time. Two of the most well
known motion profiles are the trapezoidal profile and the s-curve profile.</p>
<h3>The trapezoidal motion profile</h3>
<p>The trapezoidal motion profile consist of three distinct phases. During the first phase a constant
positive acceleration is applied. This leads to a linearly increasing velocity until the maximum
velocity is achieved. During the second phase no acceleration is applied, keeping the velocity constant.
Finally in the third phase a constant negative acceleration is applied, leading to a decreasing
velocity until the velocity becomes zero.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_trapezoidal_motion_profile.png" target="_blank">
    <img
        alt="Position, velocity, acceleration and jerk curves for the trapezoidal motion profile"
        src="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_trapezoidal_motion_profile.png"
        width="800"/>
  </a>
  <figcaption>Position, velocity, acceleration and jerk curves for the trapezoidal motion profile.</figcaption>
</figure>
<p>The equations for the different phases are as follows</p>
<p>The acceleration, velocity and position in each phase of the trapezoidal motion profile can be
described with the standard <a href="https://en.wikipedia.org/wiki/Equations_of_motion">equations of motion</a>.</p>
<p>
  <la-tex class="block">
    v_n(t) = v_{n-1} + a_{n-1} t
  </la-tex>
</p>
<p>
  <la-tex class="block">
    r_n(t) = r_{n-1} + v_{n-1} t + \frac{1}{2} a_{n-1} t^2
  </la-tex>
</p>
<p>Where</p>
<ul>
<li><la-tex>t</la-tex> is the amount of time spend in the current phase.</li>
<li><la-tex>n</la-tex> is the current phase</li>
</ul>
<p>For my calculations I assumed that the acceleration phase and the deceleration phase take the same
amount of time, thus they have the same acceleration magnitude but different signs. With this the
differences for each phase are:</p>
<ol>
<li><la-tex>a(t) = a_{{max}}</la-tex></li>
<li><la-tex>a(t) = 0</la-tex></li>
<li><la-tex>a(t) = -a_{{max}}</la-tex></li>
</ol>
<h4>My implementation</h4>
<p>To simplify my implementation of the trapezoidal motion profile I assumed that the different stages
of the profile all take the same amount of time, i.e. one third of the total time. In real life this
may not be true because the amounts of time spend in the different stages depend on the maximum
reachable acceleration and velocity as well as the minimum and maximum time in which the profile
needs to be achieved. Making this assumption simplifies the initial implementation. At a later stage
I will come back and implement more realistic profile behaviour.</p>
<p>Additionally my motion profile code assumes that the motion profile is stored for a relative
timespan of 1 unit. If I want a different timespan I can just multiply by the desired
timespan to get the final result. For this case we can now determine what the
maximum velocity is that we need in order to travel the desired distance.</p>
<p>
  <la-tex class="block">
    r = 0.5 * v * t_{accelerate} + v * t_{constant} + 0.5 * v * t_{decelerate}
  </la-tex>
</p>
<p>Where</p>
<ul>
<li><la-tex>t_{{accelerate}}</la-tex> is the total time during which there is a positive acceleration,
which is one third of the total time.</li>
<li><la-tex>t_{{constant}}</la-tex> is the time during which there is a constant velocity, which is
also one third of the total time.</li>
<li><la-tex>t_{{decelerate}}</la-tex> is the time during which there is a negative acceleration, which
again is one third of the total time.</li>
</ul>
<p>Simplifying leads to</p>
<p>
  <la-tex class="block">
    r = \frac{2}{3} v t \Longrightarrow v = \frac{3}{2} \frac{s}{t}
  </la-tex>
</p>
<p>Using this maximum velocity and the equations for the different phases I implemented a
<a href="](https://github.com/pvandervelde/basic-swerve-sim/blob/b3cc1c7d5b4502d502493abfcb0c10cca3f5cf59/swerve_controller/profile.py#L449)">trapezoidal motion profile</a>.
The results from running this motion profile are displayed in the plots above. These plots show that
the trapezoidal has no large spikes in the acceleration profile when compared to the linear motion profile.
additionally the jerk spikes for the trapezoidal motion profile are significantly smaller than the
ones generated by the linear motion profile. So we can conclude that the trapezoidal motion profile
is a better motion profile than the linear profile. However there are still spikes in the jerk values
that would be detrimental for both humans and machinery. So it would be worth finding a better
motion profile. That motion profile is the s-curve motion profile discussed in the next section.</p>
<h3>The s-curve motion profile</h3>
<p>Where the trapezoidal motion profile consisted of three different phases, the s-curve motion profile
has seven distinct phases:</p>
<ol>
<li>The ramp up phase where a constant positive jerk is applied. Which leads to a linearly
increasing acceleration and a velocity ramping up from zero following a second order curve.</li>
<li>The constant acceleration phase where the jerk is zero. In this phase the velocity is
increasing linearly.</li>
<li>The first ramp down phase where a constant negative jerk is applied. This leads
to a linearly decreasing acceleration until zero acceleration is achieved. The velocity is still
increasing, following a slowing second order curve to a constant velocity value.</li>
<li>The constant velocity phase where the jerk and acceleration are both zero.</li>
<li>The first part of the deceleration phase where a constant negative jerk is applied.
Again this leads to a linearly decreasing acceleration, and a velocity decreasing following
a second order curve.</li>
<li>In this phase the acceleration is kept constant and the velocity decreases linearly.</li>
<li>The final phase where a constant positive jerk is applied with the goal to linearly increase the
acceleration until zero acceleration is reached. The velocity will keep decreasing following a
second order curve, until it too reaches zero.</li>
</ol>
<figure style="float:left">
  <a href="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_scurve_motion_profile.png" target="_blank">
    <img
        alt="Position, velocity, acceleration and jerk curves for the s-curve motion profile"
        src="/assets/images/robotics/control/position_velocity_acceleration_and_jerk_for_scurve_motion_profile.png"
        width="800"/>
  </a>
  <figcaption>Position, velocity, acceleration and jerk curves for the s-curve motion profile.</figcaption>
</figure>
<p>As with the trapezoidal motion profile, the acceleration, velocity and position in each phase of the
s-curve motion profile can be described with the standard equations of motion. The difference is
that the acceleration is a linear function, which introduces a jerk value to the equations.</p>
<p>
  <la-tex class="block">
    a_n(t) = a_{n-1} + j_n t
  </la-tex>
</p>
<p>
  <la-tex class="block">
    v_n(t) = v_{n-1} + a_{n-1} t + \frac{1}{2} j_n t^2
  </la-tex>
</p>
<p>
  <la-tex class="block">
    r_n(t) = r_{n-1} + v_{n-1} t + \frac{1}{2} a_{n-1} t^2 + \frac{1}{6} j_n t^3
  </la-tex>
</p>
<p>Where</p>
<ul>
<li><la-tex>t</la-tex> is the amount of time spend in the current phase.</li>
<li><la-tex>n</la-tex> is the current phase</li>
</ul>
<p>As with the trapezoidal motion profile I assumed that the acceleration and deceleration phases
span the same amount of time. Again this means the acceleration and deceleration have magnitude but
different signs. The differences for each phase are:</p>
<ol>
<li><la-tex>j(t) = j_{{max}}</la-tex></li>
<li><la-tex>j(t) = 0</la-tex></li>
<li><la-tex>j(t) = -j_{{max}}</la-tex></li>
<li><la-tex>j(t) = 0</la-tex>, <la-tex>a(t) = 0</la-tex></li>
<li><la-tex>j(t) = -j_{{max}}</la-tex></li>
<li><la-tex>j(t) = 0</la-tex></li>
<li><la-tex>j(t) = j_{{max}}</la-tex></li>
</ol>
<h4>My implementation</h4>
<p>To simplify my implementation of the s-curve motion profile I assumed that all stages, except stage 4,
all take the same amount of time, i.e. one eight of the total time. I assumed that stage 4 would take
one quarter of the time. Like with the trapezoidal profile making this assumption simplifies the
initial implementation. At a later stage I will come back and implement more realistic profile behaviour.</p>
<p>Additionally my motion profile code assumes that the motion profile is stored for a relative
timespan of 1 unit. If I want a different timespan I can just multiply by the desired
timespan to get the final result. For this case we can now determine what the
maximum velocity is that we need in order to travel the desired distance.</p>
<p>Using the equations above I implemented a
<a href="](https://github.com/pvandervelde/basic-swerve-sim/blob/b3cc1c7d5b4502d502493abfcb0c10cca3f5cf59/swerve_controller/profile.py#L600)">s-curve motion profile</a>.
The results from running this motion profile are displayed in the plots above. These plots show that
the s-curve removes the spikes in the jerk profile when compared to the trapezoidal motion profile.
This indicates that the s-curve motion profile achieves the goal we previously set, to minimize
the jerky motion.</p>
<p>For some applications it is important to provide even smoother motions. In this case the motion
profiles may need to take into account the values of the
<a href="https://en.wikipedia.org/wiki/Fourth,_fifth,_and_sixth_derivatives_of_position">fourth, fifth or even sixth order time derivatives of position</a>,
snap, crackle and pop. At the moment I have not implemented these higher order motion profiles.</p>
<h3>Use in the swerve simulation</h3>
<p>Having these motion profiles is great, however by themselves they are of little use. So I added them
to my swerve drive simulation to see what the differences were between the different motion profiles.</p>
<p>Before we look at the new results it is worth looking at the simulations using the linear
motion profile. I made one for <a href="https://youtu.be/LlyopmLMlZY">module control</a> and one for
<a href="https://youtu.be/U6Z_meFKNrI">body control</a>. In these simulations you can see that with the linear
motion profile the jerk spikes are quite large, especially in the case of the module control
simulation. The body control approach performs a little better with respect to the maximum levels
of jerk, however the values are still far too high.</p>
<p>The simulations for <a href="https://youtu.be/wUb6K0o4oW8">module control</a> and
<a href="https://youtu.be/Jyp3w_zgAlI">body control</a> using the trapezoidal profile show a
significant decrease in the maximum value of the acceleration and jerk values, in some cases by a
factor 15. As expected from the previous discussion there are still some spikes, especially for the
steering angles. The changes for the module control case are more drastic than for the
body control case, probably due to the fact that the values were very high for the combination
of the module control with a linear motion profile. Interestingly the acceleration and jerk
maximum values are lower for the module control approach than they are for the body control
approach. This is most likely due to the fact that in order to keep the drive modules synchronised
relatively high steering velocities are required. For instance, the module control approach using the
trapezoidal motion profile sees a maximum steering velocity of about 1.8 radians per second. Compare
this to the the body control approach with the trapezoidal motion profile which sees a maximum
steering velocity of about 3.8 radians per second.</p>
<iframe
    style="float:none"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/PxMFjGLH0xY"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>When we look at the simulations using the s-curve motion profile we can see that the maximum
acceleration and jerk values actually increase when compared to the trapezoidal motion profile, except
for the values of the steering angle jerk when using the module control approach. It seems likely that
these increases are due to the fact that the motion is executed over the same time span, but some of
the time is used for a more smooth acceleration and deceleration. This means that there is less
time available to travel the desired &lsquo;distance&rsquo; which then requires higher maximum velocities and
maximum accelerations. The s-curve motion profile does smooth out the movement profiles which would
lead to a much smoother ride.</p>
<iframe
    style="float:none"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/B3CUdHifQCQ"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<h4>What is next</h4>
<p>So now that we have a swerve drive simulation that can use both module based control and body
based control as well as have different motion profiles, what is next? There are a few improvements
that can be made to the simulation code to further made to the simulation and a path of progression.</p>
<p>The first improvement lies in the fact that none of the motion profiles, linear, trapezoidal and
s-curve, are aware of motor limits. This means that they will happily command velocity, acceleration
and jerk values that a real life motor would not be able to deliver. In order to make the simulation
better I would need to add some kind of limits on the maximum reachable values. This would be
especially interesting when using body oriented control. Because the high velocities and accelerations
are needed to keep the drive modules synchronised. If one of the drive modules is not able to reach
the desired velocity or acceleration then the other modules will have to slow down before they
reach their limits. To control the drive modules in such a way that all of the modules stay within
their motor limits while also keeping them synchronised requires some fancy math. At the moment
I'm going through a number of published papers to see what different algorithms are out there.</p>
<p>The second improvement that is on my mind is to implement some form of path tracking, i.e. the
ability to follow a given path. This would give the simulation the ability to better show the
behaviour of a real life robot. In most cases when a robot is navigating an area the path planning
code will constantly be sending movement instructions to ensure that the robot follows the originally
planned path. This means that motion profiles need to be updated constantly, which will be a challenge
for the simulation code. Additionally having path tracking in the simulation would allow me to
experiment with different algorithms for path tracking and trajectory tracking, i.e. the ability to
follow a path and prescribe the velocity at every point on the path. And theoretically with a
swerve drive it should even be possible for the robot to follow a trajectory while controlling
the orientation of the robot body.</p>
<p>Finally the path of progression is to take the controller code that I have written for this
simulation and use it with my <a href="posts/Swerve-drive-introduction">ROS2 based swerve robot</a>.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-control-animations">Swerve drive - Movement animations</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Tuesday, July 4, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
                        <a id="post-category" role="button" href="/tags/Zinger" class="btn btn-default btn-xs tag-no-wrap">Zinger</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my last two posts I talked about different control methods for a swerve drive robot. One method
controls the movement of drive modules directly. The other method controls the movement of
the body and derives the desired state for the drive modules from that.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation"
        src="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>Simulation data for a 45 degree linear track that transitions to an in-place rotation.</figcaption>
</figure>
<p>To see the difference between these control methods my simulation code created all kinds of interesting
plots like the ones above. However I was still having trouble visualizing what was actually happening,
especially in the case of the movement of the Instantaneous Centre of Rotation (ICR), i.e. the
rotation point for the robot at a given point in time. The lower left graph shows the paths the
ICR for different combinations of drive modules. While it looks pretty it does not make a lot of
sense to me.</p>
<iframe
    style="float:left"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/LlyopmLMlZY"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>So to address that issue I updated the simulation code to produce some <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/a83c0d8ce4cc3096548be51244ec0a40d2a7db8f/sim_output/animate.py">animations</a>
that display the position of the robot and the wheels as well as a number of plots for the state of
the robot body and the drive modules. To create the animations I used the
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html#matplotlib.animation.FuncAnimation">FuncAnimation class</a>
that is available in matplotlib. The animations can then either be turned into an HTML page with
animation controls using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.HTMLWriter.html">HTMLWriter</a>,
or into MP4 video files using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FFMpegWriter.html">FFMpegWriter</a>.
In order to get reasonable performance when using the animation functions in matplotlib it is important
to update the plots instead of drawing new ones. This can be done using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D.set_data">set_data</a>
function, for instance for updating the position of the <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/a83c0d8ce4cc3096548be51244ec0a40d2a7db8f/sim_output/animate.py#L784">robot body</a>.
It is good to keep in mind that even with this performance improvement the creation of the animations
isn't very fast for our robot simulation because a large number of image frames need to be made. For
the 6 second movement in the animation anywhere between 150 and 600 frames need to be created.</p>
<p>The animation above shows how the robot behaves when using the
<a href="posts/Swerve-drive-kinematics-simulation">direct module controller</a>. As you can see in the video different
pairs of wheels have different rotation points, signified by the red dots. As the movement progresses
these rotation points have quite a large range of motion. This indicates that the wheels are not
synchronized and most likely some of the wheels are slipping.</p>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/U6Z_meFKNrI"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>I created another animation for the same situation but with the
<a href="posts/Swerve-drive-body-focussed-control">body oriented controller</a>. In this case the rotation points
are all in a single location leading me to conclude that all the wheels are synchronized and little
to no wheel slip is occurring.</p>
<p>One other interesting thing you can see in the video is that the acceleration and
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)">jerk</a> values change very abruptly. In real life this
would lead to significant loads on the robot and its drive system. In the simulation this behaviour
is due to the fact that linear profile that is being used to transition from one state to another.
As mentioned before the next improvement will be to replace this linear interpolation with a control
approach that will provide <a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">smooth transitions</a>
for velocity and accelerations.</p>
<h4>Edits</h4>
<ul>
<li>July 6th 2023: Added a section discussing the use of the matplotlib animation functions.</li>
</ul>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-body-focussed-control">Swerve drive - Better movement by controlling the body motions</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, June 9, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
                        <a id="post-category" role="button" href="/tags/Zinger" class="btn btn-default btn-xs tag-no-wrap">Zinger</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my <a href="posts/Swerve-drive-kinematics-simulation">first attempt</a> to model a swerve drive I controlled
the movement of the robot by directly providing commands to the individual drive modules, i.e. by
controlling the steering angle and the wheel velocity of each of the four drive modules. Additionally
I assumed that the transition from one state (steering angle, wheel velocity) to another state would
follow a linear profile. An example of this can be seen in the graphs below. The bottom left graph shows
the linear change in steering angle for the four drive modules. It should be noted that a linear
profile isn't very realistic as this requires the motors to be capable of instant changes in velocity
and acceleration. However making this assumption keeps the calculations simple. At a later stage I
will be encoding different movement profiles amongst which a low
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)">jerk</a> profile for smooth movements.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation with a module-first control algorithm"
        src="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Simulation data for a 45 degree linear track that transitions to an in-place rotation with a
    module-first control algorithm.
  </figcaption>
</figure>
<p>The benefit of controlling the robot by directly controlling the drive modules is that the control
algorithm is very simple and all movement patterns are possible. For instance it is possible to make
all the wheels change steering angle without moving the robot body, something which is not possible
with indirect control methods.</p>
<p>However there are also a number of drawbacks. The main one is that
for a swerve drive to be efficient the motions of the different drive modules need to be synchronized.
That means that all the drive modules needs to be controlled so that none of the wheels slip along
the surface. For simple linear or rotational movements of the robot body this is easy to achieve but
for complicated movements this is much more difficult. An example is shown in image above which
describes the behaviour of the robot as it moves linearly at a 45 degree angle and then transitions
to an in-place rotation around the robot centre axis. The bottom right graph shows the
<a href="https://en.wikipedia.org/wiki/Instant_centre_of_rotation">instantaneous centre of rotation</a> calculated
for different combinations of two wheels. In a synchronised motion all wheels should point to the same
instantaneous centre of rotation at any given moment. If the ICR's for the different wheel pairs are
in different locations then one or more of the wheels is out of sync and likely slipping along
the ground. The graph clearly shows that in this case the drive modules are not synchronized thus
causing wheel slip.</p>
<p>One way to improve the synchronization between the drive modules is apply the movement control at
an indirect level, for instance on the robot body, and then to work out from there what the drive modules
should be doing at any that given point in time along the transition profile.</p>
<p>As with the previous approach I will use a
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/profile.py#L47">linear profile</a>
to determine the transitions between different body states. Then the transition for the
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/trajectory.py#L42">body velocities (x-velocity, y-velocity, and rotational velocity)</a>
can be determined from the start state to the end state. Once it is known what
the body motion looks like I can calculate the
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/multi_wheel_steering_controller.py#L100">states for the drive modules</a>
from the body state for all given states in the transition profile.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/serve_sim_module_flip_steering_angle.png" target="_blank">
    <img
        alt="Drive module steering angle flip"
        src="/assets/images/robotics/swerve/serve_sim_module_flip_steering_angle.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Drive module steering angle flip.
  </figcaption>
</figure>
<p>One issue with this approach is that every body state can be achieved by two different module states,
one with the wheel moving &lsquo;forward&rsquo; and one with the wheel moving 'backward'. Initially the simulation
was hard-coded to always select the &lsquo;forward&rsquo; moving state. However this leads to situations where
the steering angle is flipped 180 degrees very rapidly. This is shown in the figure where the yellow
line switches from 45 degrees (or 0.78 radians) to 225 degrees (or 3.9 radians) in two time steps, or
0.02 seconds. In real life this change in steering angle would likely not be possible because the
steering angle motor would not be capable of delivering the enormous velocities and accelerations
necessary to achieve this change.</p>
<p>To resolve this issue the simulation calculated the difference in rotation and velocity between the
current point in time and the previous point in time along the transition profile, for both the
forward and backward motions. Then <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/multi_wheel_steering_controller.py#L140">general rule</a>
is to pick the smallest change in both rotation and velocity of the drive module. If that isn't
possible then we pick the one with the smallest rotation difference for no real reason other than we
have to pick something. In future work a more thorough algorithm will be implemented.</p>
<p>With all that code in place the simulation delivers a much smoother result for the transition from
a 45 degree linear motion into a in-place rotation. The ICR path for all the wheel pairs is
following a single path indicating that all the drive modules are all synchronised during the
movement transition.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_body_first_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation with a body first control algorithm"
        src="/assets/images/robotics/swerve/swerve_sim_body_first_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Simulation data for a 45 degree linear track that transitions to an in-place rotation with a
    body-first control algorithm.
  </figcaption>
</figure>
<p>The body oriented control approach ensures synchronisation of the drive modules while allowing
nearly all the different motions a swerve drive can make. The only motions not possible are those
that involve drive module steering angle changes only.</p>
<p>The next improvement will be to replace the linear interpolation between the start state and the
desired end state with a control approach that will provide
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">smooth transitions</a> for velocity and
accelerations. This will make the motions of the robot less jerky and thus less likely to damage
parts while also providing a smoother ride for the payload.</p>
<h4>Edits</h4>
<ul>
<li>July 4th 2023: Changed the term <code>control trajectory</code> to <code>control profile</code> because the term
<code>trajectory</code> is generally reserved for path planning situations.</li>
<li>July 4th 2023: Changed the term <code>ICR trajectory</code> to <code>ICR path</code> because the the ICR does not
follow a trajectory, it follows a path.</li>
</ul>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-kinematics-verification">Swerve drive - Verification of the kinematics solution</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Thursday, May 4, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
                        <a id="post-category" role="button" href="/tags/Zinger" class="btn btn-default btn-xs tag-no-wrap">Zinger</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>As I explained in an <a href="posts/Swerve-drive-kinematics-simulation">earlier post</a> I have written some
code to simulate the movement of a four wheel swerve drive.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/swerve/swerve-dof.png" target="_blank">
    <img alt="Swerve drive degrees of freedom" src="/assets/images/robotics/swerve/swerve-dof.png" />
  </a>
  <figcaption>Degrees of freedom for a swerve drive system.</figcaption>
</figure>
<p>Currently I have only implemented a
<a href="https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-steering-swerve/107383">simple kinematics based approach</a>.
This approach is based on the diagram displaying degrees of freedom for the swerve drive as well as
the coordinate systems for the different parts. The simple kinematics approach makes a number of
assumptions which greatly simplify the problem space.</p>
<ul>
<li>The steering axis of a drive module is vertical and passes through the centre of the wheel, i.e.
no positional changes occur when the wheel steering angle changes.</li>
<li>The robot is moving on a flat, horizontal surface, i.e. the contact point between the wheel and
the ground is always inline with the steering axis of a drive module.</li>
<li>The robot has no suspension, i.e. the body doesn't move vertically relative to the contact
point between the wheel and the ground.</li>
<li>There is no wheel slip.</li>
<li>There is no wheel lift-off, i.e. the wheels of the robot are always in contact with the ground.</li>
<li>The motors are infinitely powerful and fast, i.e. there are no limits on the motor performance.</li>
</ul>
<p>With diagram and the given assumptions we can derive the equations for the wheel velocity
and the steering angle of each drive module.</p>
<pre><code>v_i = v + W x r_i

alpha_i = acos (v_i_x / |v_i|)
      = asin (v_i_y / |v_i|)
</code></pre>
<p>Where</p>
<ul>
<li><code>v_i</code> - the wheel velocity of the i-th drive module, i.e. the velocity at which the drive module
would move forward if there is no wheel slip. The <code>x</code> and <code>y</code> components of this vector are
named as <code>v_i_x</code> and <code>v_i_y</code>.</li>
<li><code>v</code> - the linear velocity of the robot.</li>
<li><code>W</code> - the angular velocity of the robot.</li>
<li><code>r_i</code> - the position vector of the i-th drive module.</li>
<li><code>alpha_i</code> - the steering angle of the i-th drive module relative to the robot coordinate system.</li>
</ul>
<p>Based on these equations we can determine the forward kinematics, which translates the movement
of the drive modules to the movement of the robot body, and the inverse kinematics, which translates
the movement of the robot body to the movement of the drive modules. When doing the calculations for
a four wheel swerve drive it is important to note that the forward kinematics calculations are
<a href="https://en.wikipedia.org/wiki/Overdetermined_system">overdetermined</a>, i.e. there are more control
variables than there are outputs. This means that there are additional control variables that we can
play with. One obvious one for a swerve drive is that we can control the orientation of the robot body
independent[*] from the direction of movement of the robot. This also means that the forward kinematics
calculations are based on the <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">pseudoinverse</a>
approach which computes a best fit, a.k.a. least squares, using the drive module wheel velocities and
steering angles. In order words the wheel velocities and steering angles are approximations, not exact
values.</p>
<p>The transition between states, i.e. from one combination of x-velocity, y-velocity and rotation velocity
to another combination, is done by assuming that there is linear control for the drive module variables,
i.e. wheel velocity and steering angle. While linear control profiles are not the best control
method it does allow later on only changing the profile code to use a more suitable one, for
instance a <a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">jerk limited</a> profile.</p>
<p>The code I wrote gives me a graphs like the ones presented in my <a href="posts/Swerve-drive-kinematics-simulation">previous post</a>.
However before I use this code to test new control algorithms I want to make sure my code is
actually producing the correct results. The <a href="https://en.wikipedia.org/wiki/Software_verification_and_validation">verification</a>
is done by running a bunch of simple simulations for which I am able to predict the behaviour using
some simple maths.</p>
<p>To verify that my code is correct I a ran a number of sets of simulations. The
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/linear_with_single_axis/README.md">first set</a>
is used to ensure that both the positive and the negative direction behaviour for the main axis directions.
Any differences in behaviour between the positive and the negative direction point to issues in the
simulation code. So the simulations that were done for this verification set are:</p>
<ul>
<li>Drive the robot in x-direction while facing in the x-direction, one simulation going forward from
the origin and one simulation going backwards from the origin.</li>
<li>Drive the robot in the y-direction while facing in the x-direction, one simulation going left from
the origin and one simulation going right from the origin.</li>
<li>Drive the robot in a rotation only movement, one simulation going clockwise and one simulation going
counter-clockwise.</li>
</ul>
<p>The <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/rotation_with_single_axis/README.md">second simulation set</a>
is designed to verify the coordinate calculations related to rotations. The
simulations that were done for this verification set are:</p>
<ul>
<li>Rotate the robot by 90 degrees and then drive it in the robot x-direction, driving forwards
and backwards.</li>
<li>Rotate the robot by 90 degrees and then drive it in the robot y-direction, driving left and right.</li>
</ul>
<figure style="float:right">
  <a href="/assets/images/robotics/swerve/swerve_sim_circle.png" target="_blank">
    <img
        alt="Drive the robot in a circle."
        src="/assets/images/robotics/swerve/swerve_sim_circle.png"
        width="833"
        height="800"/>
  </a>
  <figcaption>Swerve drive position and velocities for driving in a circle.</figcaption>
</figure>
<p>The <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/combined/README.md">third set of simulations</a>
is designed to verify the behaviour during combined movements. The
simulations that were done for this verification set are:</p>
<ul>
<li>Drive the robot on the 30 degree diagonals (30 degrees, 60 degrees, 120 degrees, 150 degrees),
while facing in the x-direction, one simulation going forwards from the origin and one going
backwards from the origin.</li>
<li>Drive the robot in a circle around a centre point outside the robot body.</li>
</ul>
<p>While running the verification sets a number of bugs were found and fixed. At the end of the process
all the validations passed indicating that the simulation code is usable.</p>
<p>With all of this done it is now time to do some more complicated simulations both for robot behaviour
that is specific to swerve drive systems and for different control algorithms. More on that in the next
post.</p>
<p>&ndash;</p>
<p>[*] Mostly independent. In reality the motors used in the drive modules will have
limits on how fast they can be driven, how much torque they can produce and
how fast they can change from one state to the next. This means that there
are limitations on movements of the drive modules and thus the robot body. For
instance if a drive module has a maximum linear velocity of 1.0 m/s it is
not possible to drive the robot diagonally any faster than this velocity, even
though we can drive the robot in x-direction at 1.0 m/s and we can drive the
robot in y-direction at 1.0 m/s. We just can't do both at the same time.</p>
<h4>Edits</h4>
<ul>
<li>July 4th 2023: Changed the term <code>control trajectory</code> to <code>control profile</code> because the term
<code>trajectory</code> is generally reserved for path planning situations.</li>
</ul>

                </div>
            </div>
        </div>
            </div>
        </div>

        <footer>
            <div id="footer" class="container">
    <div id="fbox1">
        <h2>Related</h2>
        <ul>
            <li><a href="https://github.com/pvandervelde"><i class="fa fa-github"></i> GitHub</a></li>
            <li><a href="https://www.linkedin.com/profile/view?id=33950311"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
            <li><a href="https://stackoverflow.com/users/539846/petrik"><i class="fa fa-stack-overflow"></i> StackOverflow</a></li>
            <li><a href="https://careers.stackoverflow.com/pvandervelde"><i class="fa fa-stack-overflow"></i> StackOverflow Careers</a></li>
            <li><a href="https://profile.codersrank.io/user/pvandervelde">CodersRank</a></li>
        </ul>
    </div>
    <div id="fbox2">
        <h2 id="copyright">Copyright</h2>
        <p>Copyright (c) 2024 <a href="/">Petrik van der Velde</a>. All rights reserved.</p>

        <h2 id="disclaimer">Disclaimer</h2>
        <p>The opinions expressed herein are my own personal opinions and do not represent my employer's view in any way.</p>
    </div>
    <div id="fbox3">
        <h2 id="media">Media</h2>
        <p><a href="/feed.atom"><img src="/assets/images/feed.png" alt="Atom feed"></a></p>
    </div>
</div>
<div id="copyright" class="container">
    <div>
        <p>
            Generated by <a href="https://wyam.io">Wyam</a> on Tue, 16 Jan 2024 03:08:48 GMT

 from commit <a href="https://github.com/pvandervelde/mindvortex/tree/ec6bf08dcdd12489e8f93da6a36c3ec16c2670a9">ec6bf08dcdd12489e8f93da6a36c3ec16c2670a9</a> at version 3.18.1.        </p>
    </div>

    <p>
        Site design based on the <a href="https://www.freecsstemplates.org/previews/opentools/">Open Tools</a> design
        by <a href="https://www.freecsstemplates.org">FreeCSSTemplates.org</a>.
    </p>
    <p>
        Feed icon by <a href="https://www.icojam.com/">Icojam</a> and Favicon by
        <a href="https://www.flaticon.com/free-icon/twister-sky-wind_12318" title="Yannick">Yannick</a>
        from <a href="https://www.flaticon.com" title="Flaticon">www.flaticon.com</a>
    </p>
</div>

        </footer>
    </body>
</html>
