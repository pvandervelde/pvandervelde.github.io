
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Mind vortex</title>
        <meta name="description" content="Welcome!" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link type="application/rss+xml" rel="alternate" title="Mind vortex" href="/feed.rss" />
        <link type="application/atom+xml" rel="alternate" title="Mind vortex" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/normalize.css" rel="stylesheet" />
        <link href="/assets/css/h5bp.css" rel="stylesheet">
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
        <link href="/assets/css/override.css" rel="stylesheet" />
        <link href="/assets/css/github.css" rel="stylesheet" type="text/css">


        <meta name="application-name" content="Mind vortex" />
        <meta name="msapplication-tooltip" content="Mind vortex" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Mind vortex" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://www.petrikvandervelde.nl/" />
        <!-- TODO: More social graph meta tags -->

        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>
        <script src="/assets/js/highlight.pack.js"></script>
        <script src="/assets/js/clean-blog.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="/assets/js/html5shiv.js"></script>
                <script src="/assets/js/respond.min.js"></script>
        <![endif]-->

        <!-- Our scripts -->
<script src="/assets/js/script.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DV643VJGFT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DV643VJGFT');
</script>


    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->
        <div id="header" class="container">
            <div id="logo">
                <h1><a href="/">Mind vortex</a></h1>
            </div>
            <div id="menu">
                <ul>
                            <!-- Pages -->
        <!-- BlogPosts -->
        <!-- Tags -->
        <!-- TagIndex -->
        <!-- BlogArchive -->
        <!-- Index -->
    <!-- Context.Documents['Pages'] -->
        <!-- 404 Not Found - False - /404 -->
        <!-- About - True - /about -->
        <!-- Calvinverse - False - /projects/calvinverse -->
        <!-- nBuildKit - False - /projects/nbuildkit -->
        <!-- Projects - True - /projects -->
        <!-- Scuttle - False - /projects/scuttle -->
            <li class="active" >
                Home
            </li>
            <li class="inactive" >
                <a href="/projects">Projects</a>
            </li>
            <li class="inactive" >
                <a href="/posts">Archive</a>
            </li>
            <li class="inactive" >
                <a href="/tags">Tags</a>
            </li>
            <li class="inactive" >
                <a href="/about">About</a>
            </li>

                </ul>
            </div>
        </div>

        <div id="page" class="container">
            <div id="sidebar">
                <div id="sbox1">
                    <h2>Patrick van der Velde</h2>

<p>
    <img src="https://www.gravatar.com/avatar/9bc8b3ff385cd14f2b12138c97729df2?s=160" alt="Gravatar for Patrick van der Velde">
</p>
<p>
    Dutch software developer who is living, working and playing in New Zealand.
    Rock climber and paragliding pilot. Developer of
    <a href="https://nbuildkit.github.io/nBuildKit.MsBuild/">nBuildKit</a>,
    <a href="https://github.com/Calvinverse">the Calvinverse resources</a> and other projects.
</p>
<p>
    <a href="/about.html">More ...</a>
</p>

                </div>
                <div id="sbox2">
                    <h2>Recent</h2>
                    <ul class="list-unstyled">
                            <li><a href="/posts/Swerve-drive-introduction">Swerve drive - Moving a robot in all directions, mostly</a></li>
                            <li><a href="/posts/Robotics-fixing-scuttles-encoder">Starting robotics - Fixing the wheel encoders</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-electronics">Starting robotics - Building a bumper for scuttle. The electronics</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-overview">Starting robotics - Building a bumper for scuttle. The overview</a></li>
                            <li><a href="/posts/Robotics-driving-scuttle-with-ros-gazebo-simulation">Starting robotics - Driving scuttle with ROS - Gazebo simulation</a></li>
                            <li><a href="/posts/Robotics-learning-ros">Starting robotics - Learning Robot Operating System (ROS)</a></li>
                            <li><a href="/posts/Starting-robotics-with-scuttle">Starting robotics with the SCUTTLE robot</a></li>
                            <li><a href="/posts/Building-autonomous-mobile-robot-why">Building an autonomous mobile robot - But why?</a></li>
                            <li><a href="/posts/Software-development-pipeline-security">Software development pipeline - Security</a></li>
                    </ul>
                </div>
                <div id="sbox3">
                    <h2>Tags</h2>
                    <div>
                        <ul class="list-unstyled">
                                <li>
                                    <a role="button" href="/tags/Sherlock" class="btn btn-default btn-sm"> Sherlock (13)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/nBuildKit" class="btn btn-default btn-sm"> nBuildKit (12)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/DevOps" class="btn btn-default btn-sm"> DevOps (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Delivering-software" class="btn btn-default btn-sm"> Delivering software (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Software-development-pipeline" class="btn btn-default btn-sm"> Software development pipeline (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/PG2" class="btn btn-default btn-sm"> PG2 (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Robotics" class="btn btn-default btn-sm"> Robotics (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Paragliding" class="btn btn-default btn-sm"> Paragliding (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Blog" class="btn btn-default btn-sm"> Blog (7)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Nuclei" class="btn btn-default btn-sm"> Nuclei (6)</a>
                                </li>
                        </ul>
                    </div>
                    <br />
                    <ul class="pager">
                        <li class="next">
                            <a href="/tags">View All Tags &rarr;</a>
                        </li>
                    </ul>
                </div>
            </div>

            <div id="content">

        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-introduction">Swerve drive - Moving a robot in all directions, mostly</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Sunday, December 4, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>Over the last year I have been using my <a href="https://www.scuttlerobot.org/">SCUTTLE robot</a> as a way of
learning about robotics and all the related fields like mechanics and electronics. A major part of
this journey is the desire to design and build an autonomous mobile robot from the ground up.</p>
<p>My goal is to build an off-road capable robot that can navigate autonomously between different
locations to execute tasks either by itself or in cooperation with other robots. This is
quite an inspirational goal that involves quite a few robot different parts, a lot
of code and many hours of building and testing to achieve.</p>
<p>The chassis of the robot will have four drive modules. Each module has one wheel attached that will
both be independently driven, and independently steerable. This configuration is called
<code>four wheel independent steering</code> or <code>swerve drive</code>. These kind of steering systems are used in
<a href="https://en.wikipedia.org/wiki/Self-propelled_modular_transporter">heavy transport</a>,
agriculture machines, <a href="https://en.wikipedia.org/wiki/Curiosity_(rover)">mars rovers</a> and
<a href="https://www.chiefdelphi.com/t/best-frc-swerve-drive/399865">robot competitions</a>. The advantages of
a swerve drive system are that:</p>
<ul>
<li>It provides a high degree of mobility. In a swerve drive direction of movement and orientation
are independent so the robot can face forwards while driving sideways. Additionally in a swerve drive
the <a href="https://en.wikipedia.org/wiki/Instant_centre_of_rotation#:%7E:text=The%20instant%20center%20of%20rotation,a%20particular%20instant%20of%20time.">Instantaneous Center of Rotation (ICR)</a>
is not fixed to a specific line as it is with <a href="https://en.wikipedia.org/wiki/Ackermann_steering_geometry">Ackermann steering</a>
or <a href="https://en.wikipedia.org/wiki/Differential_wheeled_robot">differential drive</a>. This flexibility
allows the swerve drive to combine rotational movements with linear movements in ways that
other drive systems cannot.</li>
<li>It has normal size wheels which provide a high carry capacity. While
<a href="https://en.wikipedia.org/wiki/Omni_wheel">omni-wheels</a> have the similar degree of freedom as a
swerve drive does, omni-wheels but can often not carry the same load due to the lower carrying
capacity of the rollers.</li>
<li>It doesn't rely on wheel slip, as multi-wheel differential drive does. This means that it has
lower power demands, so more of the motor torque can be used to move the robot forward.</li>
<li>It has the ability to traverse rough and dirty terrain due to the fact that all wheels are
driven as well as using normal wheels on each drive module. Omni-wheels and <a href="https://en.wikipedia.org/wiki/Mecanum_wheel">mecanum wheels</a>
face more issues in these environments due to dust and dirt clogging up the wheels as well as
having greater difficulty tackling obstacles.</li>
<li>It is able to keep ground disturbance to a minimum as it is able to steer the robot while minimizing
sliding movement. Other drive systems, e.g. tracks or multi-axle differential drives, have a bigger
impact due to the sliding movement required for these systems to turn the robot.</li>
</ul>
<p>Of course the swerve drive system isn't a magical system that only has advantages. There are also plenty
of disadvantages. For instance swerve drive systems:</p>
<ul>
<li>Are mechanically complicated. They require multiple motors per unit and multiple units per robot.
On top of that there are usually a number of mechanical components, gears and bearings, involved
in getting a working swerve drive.</li>
<li>Need a complicated control system. Swerve systems are generally
over-determined, i.e. they have more degrees of freedom in the drive system, 2 per drive module,
than there are degrees of freedom in the robot, 2 translation directions and a rotation. This
means that all modules have to be synchronised at all times in order to prevent wheels from being
dragged along. The available degrees of freedom combined with the synchronisation demand means some
complicated math is required to make a swerve drive control work.</li>
<li>Similar to the control side of the drive determining the position and velocity of the robot using
wheel <a href="https://en.wikipedia.org/wiki/Odometry">odometry</a> requires more complicated math. This is
due to the fact that the different drive modules don't necessarily agree with each other.</li>
<li>Have more failure modes than other drive systems due to the fact that there are more moving parts.</li>
</ul>
<p>So with all these complications why would I try to build a swerve drive as my second robot and not
a differential drive robot or something similar. As pointed out previously there are good
reasons to use a swerve drive in an outdoor environment, i.e. high agility, good load capacity,
traction from all wheels, low ground impact. However the main reason I want to design and build a
swerve drive is because it is a challenge. Swerve drives are complicated and designing and building
one involves solving interesting problems in mechanical engineering, electrical engineering and
software engineering.</p>
<p>There is currently no complete design for this robot yet, however there is a short list of design
decisions that have been made so far.</p>
<ul>
<li>It will be a four wheel swerve drive robot. Swerve drives have been built with anything from
three wheels up, e.g. the Curiosity mars rover has 6 drive modules. The reason to use four modules
is that it will be symmetrical and still minimize the number of parts necessary.</li>
<li>The software for the robot will be using <a href="https://docs.ros.org/en/humble/index.html">ROS2 Humble</a>.
Using ROS should provide me with a base framework and a lot of standard capabilities, like the
navigation stack, that I won't have to write myself. Additionally ROS has a decent simulation
environment that will allow me to test my code before putting it on a real robot.</li>
<li>The hardware will be controlled using <a href="https://control.ros.org/master/index.html">ROS2 controllers</a>.
This will allow me to abstract the hardware so that I can better test the controller.</li>
<li>The initial design will be an indoor model and about the same size as my SCUTTLE robot is. This will
simplify the initial design and allow me to compare with SCUTTLE.</li>
</ul>
<p>The parts of the robot that I expect to be complicated and quite possibly show stoppers are the
software and the mechanical design. For the software the drive controller software, which translates
the requested velocity commands to motor commands for both the drive and steering motors, will be
complicated as it needs to make sure that all drive modules are the correct state. This piece of
software also needs to handle all the error conditions that occur.</p>
<p>On the mechanical side I need to design the drive module such that it can drive the wheel forwards
and backwards while allowing &lsquo;infinite&rsquo; steering rotation. This will require a co-axial setup and a
bit of gearing. The second complicated part of the mechanical design is the inclusion of a suspension
system. Ideally the motors should be attached to the sprung side of the suspension system so that
they don't get exposed to excessive vibration. This however will complicate the mechanical design.</p>
<iframe
    style="float:left"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/fR47Y7p4mtQ"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe>
<p>My plan is to work on the control software first. I can test that software using simulation and so
figure out if I can even make it work. I have created a simple URDF model that uses
ROS2 controllers to simulate a four wheel steering platform. This allowed me to learn more about
ROS2, ROS2 controls and how the interaction of those two with Gazebo works.</p>
<p>At the moment I'm implementing a prototype for the controller in python so that I can use the model to
test if my algorithm works before I turn it into a proper ROS2 controller, which will need to be
written in C++.</p>
<p>Once I have some kind of controlling software I am aiming to build a single drive module with a drive
motor, a steering motor and the mechanical assembly that allows a single wheel to be steered and driven.
I will use this module to work out both the details on the mechanical and software sides of the project.</p>
<p>Once I have the controller and the drive module working properly I will build a simple robot, similar
in size to my SCUTTLE robot to further work on swerve drives. It will take me a little while
to get to that state though. In the mean time I will keep working on my design and documenting my
journey.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-fixing-scuttles-encoder">Starting robotics - Fixing the wheel encoders</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Tuesday, November 15, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
                        <a id="post-category" role="button" href="/tags/Sensors" class="btn btn-default btn-xs tag-no-wrap">Sensors</a>
                        <a id="post-category" role="button" href="/tags/Wheel-encoders" class="btn btn-default btn-xs tag-no-wrap">Wheel&nbsp;encoders</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>While testing the <a href="posts/Robotics-a-bumper-for-scuttle-electronics">bumper</a> for SCUTTLE I noticed
that when reversing SCUTTLE would start a turn instead of driving straight backwards due to one
motor turning faster than the other motor. There are a number of reasons this could be happening,
for instance the driver code isn't properly commanding the motors, or the encoders are returning
incorrect data, etc..</p>
<figure style="float:left">
<img alt="Encoder output for failing encode" src="/assets/images/robotics/scuttle/scuttle-encoder-fail.png" />
<figcaption>Encoder output for failing encoder</figcaption>
</figure>
<p>The first thing I did for my investigation was to make sure my encoders provide sensible data. The
non-ROS SCUTTLE code contains a useful <a href="https://github.com/scuttlerobot/SCUTTLE/blob/ce82a52ad025408a15f23f19c58add1321253783/software/python/basics/L1_encoder.py">Python script</a>
to measure the current value of the wheel encoders in a loop. I ran this code for a few minutes
while the wheels were stationary. In theory the results of this measurement should be two consistent
values, one for the left encoder and one for the right encoder. As you can see in the graph
it turns out that the angle measurement provided by the left encoder was very noisy.</p>
<p>While a noisy encoder shouldn't by itself cause the incorrect reversing pattern, it will make it more
difficult to find the actual cause of the problem. So before I address the bumper reversing behaviour
I needed to fix the encoder noise. The two main reasons for noisy encoder data that I could think of
were:</p>
<ul>
<li>The encoder is broken in some way. SCUTTLE uses the
<a href="https://nz.mouser.com/ProductDetail/ams-OSRAM/AS5048B-TS_EK_AB?qs=Rt6VE0PE%2FOduJIB%252BRfeBZQ%3D%3D">AS5048A position sensor</a>
which is relatively robust, but can be broken if you send the I2c commands on the wrong pins. Which
could happen if you say ... put the connector on the wrong way when assembling your SCUTTLE ...</li>
<li>The distance between the encoder and the magnet on the motor shaft isn't correct. The specifications
for the encoder state that the distance between the chip and the magnet on the motor shaft should
be between 0.5mm and 2.5mm, assuming a magnet of the recommended size and strength is used.</li>
</ul>
<p>I tried measuring the distance between the encoder and the magnet, but that isn't easy. There is no way
to get a measuring tool near that space so I had to resort to indirect measurements. I measured the
left and right brackets. They were about 0.5mm difference in size. That doesn't seem much but it
would be enough to push the encoder out too far from the magnet.</p>
<p>One solution would be to slightly sand the taller bracket so that both brackets are the size height.
In doing that I would have to be very careful to ensure that I sand the bracket flat, i.e. with
no change in angle in the face. A second solution is to remove the encoders from their brackets and
swap the brackets over.</p>
<figure style="float:right">
<img alt="Encoder output for functioning encoders" src="/assets/images/robotics/scuttle/scuttle-encoder-fixed.png" />
<figcaption>Encoder output for functioning encoders</figcaption>
</figure>
<p>As the latter is relatively easy to do that is the first solution I tried. I took the encoders
of their brackets and attached them to the other bracket. These brackets were put back on SCUTTLE and
the test script was executed once again. And this time both encoders gave me consistent results. I was
expecting the other encoder to go bad due to distance, but apparently both encoders are with in the
distance specification with this new configuration.</p>
<p>With the encoder issue fixed I can get back to diagnosing the issue with the bumper reverse action.
My current suspicion is that the issue is caused by the fact that the the current SCUTTLE driver
code is written as an <a href="https://en.wikipedia.org/wiki/Open-loop_controller">open loop</a>. This means
that there is no feedback to the motor control software that indicates how fast the wheels are
actually turning in response to a given motor input. And because even motors of the same type
are all slightly different, they all react differently to the same motor input. In my case at
low speeds one of my motors responds earlier than the other motor. In the end this means that
at low speeds the bumper code thinks scuttle is driving backwards in a straight line while it
is actually driving around in circles.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-a-bumper-for-scuttle-electronics">Starting robotics - Building a bumper for scuttle. The electronics</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, October 21, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>The final part of building a bumper for SCUTTLE is to assemble the electronics component which translates
the movement of the bumper into signals which can be processed by the bumper software. In order to do
this I designed a simple circuit using <a href="https://www.kicad.org/">KiCad</a> and advice from one of the
many robotics forums.</p>
<figure style="float:left">
<img alt="SCUTTLE bumper electronics schematic" src="/assets/images/robotics/scuttle/scuttle-bumper-kicad.png" />
<figcaption>SCUTTLE bumper electronics schematic made in KiCad</figcaption>
</figure>
<p>The circuit contains a microswitch as the trigger. The switch is connected to one of the 3.3V output
pins on the raspberry PI 4 board on one side and to one of the GPIO pins on the other side. When
the switch is depressed the circuit closes and the GPIO pin is driven to 3.3V, which is considered
a high signal. In order to ensure that the voltage on the GPIO pin is 0V when the circuit is not
closed I added a <a href="https://en.wikipedia.org/wiki/Pull-up_resistor">pull down</a> resistor. On the
raspberry PI it is possible to programmatically add a pull down resistor, however because I'm
using this as a learning exercise I thought it would be more suitable to include a physical pull down
resistor in the circuit.</p>
<p>The next thing I wanted from the circuit was the ability to see if the circuit was closed or not, so
that when I'm debugging it is obvious if there is a problem with the power, electronics or software.
For this purpose I added a yellow LED to the circuit, which lights up when the circuit is closed.
Adding the LED then adds the requirement to protect it from over current in case that the input pin
was programmed to be an output pin by mistake. For this purpose I added a resistor next to the input
pin.</p>
<figure style="float:right">
<img alt="SCUTTLE bumper electronics boards" src="/assets/images/robotics/scuttle/scuttle-bumper-electronics-boards.jpg" />
<figcaption>SCUTTLE bumper electronics boards</figcaption>
</figure>
<p>After testing the circuit on the breadboard the next step was to solder two switch boards and
a distribution board. Each switch board would have a micro-switch, the LED, the resistors and a
JST-XH three pin connector for power, ground and signal wires.
The distribution board would have four JST-XH three pin connectors and one JST-XH six pin connector.
The four three pin connectors would allow me to have a front bumper and a rear bumper, each
having a switch board on the left and the right. I used JST-XH connectors instead of the Dupont
connectors because the JST connectors are directional, thereby removing any potential issues with
plugging the connector in the wrong way.</p>
<p>Part of this journey involved learning how to solder electronics components. I bought a Weller WE 1010
soldering station for this and future jobs. I managed to do a reasonable job soldering the parts but
it is obvious that I still have a lot to learn when it comes to soldering.</p>
<figure style="float:left">
<img alt="SCUTTLE bumper electronics assembled" src="/assets/images/robotics/scuttle/scuttle-bumper-assembled.jpg" />
<figcaption>SCUTTLE bumper electronics assembled</figcaption>
</figure>
<p>The last task was to crimp the connectors and connect the boards. Because the raspberry Pi has a
Dupont header I needed to crimp both Dupont connectors and JST-XH connectors. For the Dupont connectors
I got an Iwiss SN-025 crimper. It works pretty well for those connectors. However the crimper dies are
too wide for the JST-XH connectors. So to crimp the JST-XH connectors I had to get a different
crimper with narrower dies. So for this I got an Engineer PAD-11 crimper. While this is not a
ratcheting crimper it works really well, at least for the JST-XH connectors.</p>
<p>So now that the mechanical setup is done, the software is, mostly, done and the electronics have
been soldered and connected my bumper works. Sort of. It turns out that there is a
problems with my SCUTTLE that make the bump response only work partially. It seems that
there is an issue with the wheel encoders, which causes the software to not know how much one of the
wheels has rotated. I will discuss fixing the encoders in another post.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, September 9, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my <a href="posts/Robotics-a-bumper-for-scuttle-overview">previous post</a> I talked about creating a bump
sensor for my SCUTTLE robot. After creating the mechanical design I started working on the software.
There are two parts to the software, translating the state of the micro switches and turning the state
changes into movement commands for the robot, i.e. if the robot runs into
an obstacle it should stop and reverse its last movement. I decided to create a
<a href="https://www.ros.org/">ROS</a> node for each of these actions, i.e. one node
for the movement generation and one to translate the switch states. The reason for
creating two nodes instead of putting all the code into one node is that this allows me to run the
movement generation code both in a simulation and on the physical robot. So I gain the ability to
test more of my code, but I lose a bit of performance because the two nodes communicate using
messages which is slower than just using method calls.</p>
<p>To test the bump sensor code I use <a href="https://gazebosim.org/home">Gazebo</a> to simulate how the bump
sensor would work. Gazebo has the ability to calculate collisions
and create <a href="http://docs.ros.org/en/api/gazebo_msgs/html/msg/ContactsState.html">ContactsState</a>
messages based on these collision calculations. So I created a third ROS node to translate these
Gazebo messages to my own <a href="https://github.com/pvandervelde/scuttle_ros_msgs/blob/noetic/msg/BumperEvent.msg">bumper event messages</a>.
With that I can test my obstacle response code in Gazebo which provides a more controlled environment
than the physical robot does.</p>
<p>The first thing to do is to update the robot definition to include the bumper. This is done by adding
the <a href="http://wiki.ros.org/urdf/XML/link">links</a> and <a href="http://wiki.ros.org/urdf/XML/joint">joints</a> that
make up my bumper to an <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/urdf/bumper.xacro">URDF file</a>.
This URDF file is linked to the main <a href="https://github.com/scuttlerobot/scuttle_description">model description</a>
for SCUTTLE. After that I added the information for the <a href="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins#Bumper">Gazebo bumper sensor</a>.
In the URDF file this looks as follows:</p>
<pre><code>    &lt;gazebo reference=&quot;front_bumper_plate_left_link&quot;&gt;
        &lt;sensor name=&quot;front_bumper_left&quot; type=&quot;contact&quot;&gt;
            &lt;selfCollide&gt;true&lt;/selfCollide&gt;
            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;
            &lt;updateRate&gt;15.0&lt;/updateRate&gt;
            &lt;material&gt;Gazebo/WhiteGlow&lt;/material&gt;
            &lt;contact&gt;
                &lt;collision&gt;base_link_fixed_joint_lump__front_bumper_plate_left_cl_collision_3&lt;/collision&gt;
                &lt;topic&gt;bumper_contact&lt;/topic&gt;
            &lt;/contact&gt;
            &lt;plugin name=&quot;gazebo_ros_bumper_controller_front_left&quot; filename=&quot;libgazebo_ros_bumper.so&quot;&gt;
                &lt;bumperTopicName&gt;scuttle_bumper&lt;/bumperTopicName&gt;
                &lt;frameName&gt;front_bumper_plate_left_link&lt;/frameName&gt;
            &lt;/plugin&gt;
        &lt;/sensor&gt;
    &lt;/gazebo&gt;
</code></pre>
<p>I found that defining a contact sensor for Gazebo requires getting the link ID correct. In order to
do so you need to follow these steps:</p>
<ul>
<li>The bumper contact information needs to be defined inside a <a href="https://classic.gazebosim.org/tutorials?tut=ros_urdf&amp;cat=connect_ros"><code>gazebo</code></a>
element. This <code>gazebo</code> element should have a <code>reference</code> attribute that points to the link that is
to be used as the bumper surface.</li>
<li>The name for the <code>collision</code> element needs to be found after translation to the SDF format. Normally
this is something Gazebo does internally. In this case you'll need to do this manually. If your
geometry is defined in an <a href="http://wiki.ros.org/xacro">xacro</a> file then you first need to translate
this to URDF using the <code>rosrun xacro xacro --inorder -o model.urdf model.urdf.xacro</code> command. After
that you can translate the URDF to SDF with the <code>gz sdf -p scuttle.urdf &gt; scuttle.sdf</code> command. Once
you have the SDF file you can search for the
<a href="https://answers.gazebosim.org/question/21992/what-collision-name-is-supposed-to-be-passed-to-contact-sensor/">correct element IDs</a>.</li>
</ul>
<p>In the above example the collision name, <code>base_link_fixed_joint_lump__front_bumper_plate_left_cl_collision_3</code>,
is the one you need to extract from the SDF file. Note that it can change if you make changes to
your xacro / URDF file, so in that case you will need to extract it again.</p>
<p>Once you have defined the URDF Gazebo will generate contact messages when the bumper hits an object.
These contact messages contain information describing where the contact occurred on the geometry mesh,
so in theory I could have used this information to determine if the contact would trigger the left
limit switch or the right limit switch or both. However that requires a decent amount of calculations
which is both work and introduces the potential for errors. So I opted to split the bumper into
two parts, one for the left side and one for the right side. If anything contacts anywhere on the
left side I consider that a trigger for the left part of the bumper and similar for the right side.</p>
<figure style="float:left">
<img alt="SCUTTLE with bumper in RViz" src="/assets/images/robotics/scuttle/scuttle-with-bumper-in-rviz.png" />
<figcaption>SCUTTLE with bumper in RViz</figcaption>
</figure>
<p>With the URDF work done I started writing the code for the different ROS nodes. First
the <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/gazebo_contact_sensor_translator.py">gazebo translator node</a>.
This node subscribes to the <a href="http://docs.ros.org/en/api/gazebo_msgs/html/msg/ContactsState.html">ContactsState</a>
messages that Gazebo sends when the bumper geometry collides with something. These messages are then
translated to a <a href="https://github.com/pvandervelde/scuttle_ros_msgs/blob/noetic/msg/BumperEvent.msg">BumperEvent</a>
message for further processing.</p>
<p>One interesting observation about the Gazebo contact messages are that they exhibit something
similar to <a href="https://www.pcmag.com/index.php/encyclopedia/term/switch-bounce">switch bounce</a>, in other
words it seems that the contact is intermittent even if the bumper plate is in solid contact with
the object. I'm guessing that this is caused by the fact that calculating collisions between moving
surfaces is difficult. In the end it doesn't matter what causes this behaviour though because we
need to <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/debounce.py">deal with it</a> in
some sensible way.</p>
<p>Once the bumper event messages have been generated they are processed by the
<a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/bumper_navigator.py">second node</a>.
This node subscribes to both odometry events and bumper events. Internally it keeps track of the
motion state of SCUTTLE. On reception of a bumper event the node sends a
<a href="http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html">velocity command</a>
to stop the robot. Once the robot has stopped it sends commands for it to reverse course far enough
that it is no longer contact with the obstacle.</p>
<p>One thing to note is that while the bumper code is working to reverse course after hitting an obstacle,
the other parts of ROS, e.g. the navigation stack, are probably still trying to steer the robot in the
original direction because those parts don't know about the obstacle. After all it is not on the
navigation map. This results in many different velocity commands being send, which could be very
confusing for the robot. One design decision was to make the bumper code unaware of other nodes. This
was done because allowing the bumper code to supress velocity
commands from other nodes would imply that the bumper code is always the most important publisher
when it comes to velocity commands. There are cases where this isn't true, e.g. when using
the bumpers to park SCUTTLE against a specific object like in the case of a docking station.</p>
<p>To ensure that a consistent set of velocity commands are sent to the motors I used the
<a href="http://wiki.ros.org/twist_mux">twist multiplexer node</a> which takes in velocity commands from
many nodes and forwards them using a priority-based scheme. In the current implementation the
priorities are, from low to high</p>
<ul>
<li>Navigation</li>
<li>Keyboard</li>
<li>Bumper</li>
<li>Joypad / Joystick</li>
</ul>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/SddexyGTJ0M"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe>
<p>By using the twist multiplexer mode it is easy for users to change the priority by changing a configuration
file instead of having to change the bumper code.</p>
<p>With that the bumper code is able to make SCUTTLE respond to objects it bumps into. The next step in
the process of adding bump sensors to SCUTTLE is to assemble the electronic components so that the
movement of the bumper can be registered and reported to the software components.</p>
<p>Finally a addition to the software that needs to be made is the ability to add the obstacles in the
navigation map so that SCUTTLE can navigate around the newly discovered obstacles.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-a-bumper-for-scuttle-overview">Starting robotics - Building a bumper for scuttle. The overview</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Saturday, August 27, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In order to allow my SCUTTLE robot to drive around autonomously it needs some sensors so that it
can <a href="https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping">perceive its surroundings</a>.
One of the ways in which this is normally achieved is by adding a <a href="https://en.wikipedia.org/wiki/Lidar">LIDAR</a>
unit. Unfortunately I don't have one of those, and LIDAR units are relatively expensive in New Zealand.
Additionally I figured I'd learn more about robot sensors if I set up some simple sensors for my
SCUTTLE robot before getting a LIDAR.</p>
<figure style="float:left">
<img alt="CAD model of the SCUTTLE bumper" src="/assets/images/robotics/scuttle/scuttle-bumper-cad-model.png" />
<figcaption>The CAD model of the SCUTTLE bumper</figcaption>
</figure>
<p>So I decided to start with the simplest kind of sensor, the bump sensor. This type of sensor
consists of one or more <a href="https://en.wikipedia.org/wiki/Limit_switch">limit switches</a> and a bumper
surface, i.e. some kind of plate that bumps into things. This plate is held in place by springs thereby
giving it the ability to move while also returning to its original position.
When the robot bumps into an object with the plate, the springs are compressed and the plate hits
the limit switches. These switches then signal the robot that it has hit something. At that point the
robot can stop its motion and back away from the obstacle. As the robot backs away the springs push the
bumper plate away from the limit switches. The change in switch state then signals to the robot that
it is no longer in contact with the obstacle and can thus continue on its journey.</p>
<p>Overall this doesn't sound very complicated so it should be pretty quick and easy to build the
bump sensor ...</p>
<p>Several weeks down the line I nearly finished my bump sensors</p>
<p>The first part of my build was the design of the physical parts that I need to attach to SCUTTLE. I
build the bumper with simple parts because I don't have access to a workshop or a 3D printer. So
the bumper is a UHMWPE plate reinforced by some 90 degree aluminium extrusions. This prevents the
plate from flexing when it contacts an obstacle. The plate is attached to two angle brackets, one on
the left side and one on the right side. It is attached using four M3 bolts wrapped with springs,
2 bolts for each side. The idea behind using 2 bolts per side is that this should provide some
rotational stability while keeping the construction simple. Finally the angle brackets is attached
to the scuttle frame with two T slot nuts.</p>
<p>I found that the springs that keep the plate in the extended position have to be quite soft, otherwise
SCUTTLE won't be able to compress the springs when it hits something at low speed. The first
set of springs I got from Amazon were too stiff. For the second set of springs I got some ballpoint
pen springs of Aliexpress which are much less stiff.</p>
<figure style="float:right">
<img alt="SCUTTLE with its new bumper" src="/assets/images/robotics/scuttle/scuttle-with-bumper.jpg" />
<figcaption>SCUTTLE with its new bumper</figcaption>
</figure>
<p>This first version of the bumper mechanics works relatively well but for the next version there
are some things I want to change</p>
<ul>
<li>The bolts have full thread on them which sometimes causes the bolts to get hung up on the tread. I
had some issues finding partially threaded bolts with the right length and diameter.</li>
<li>The current design allows left to right tilt which is good, but also top to bottom tilt. The latter
is not so good as it potentially allows SCUTTLE to hit an obstacle without noticing. A better design
would allow left to right rotation of the bumper but little to no top to bottom rotation. This
allows the left and right limit switches to be triggered individually when SCUTTLE hits an obstacle
on the left or right side respectively while ensuring that the limit switches are always triggered
if the bumper hits something, even if the obstacle is low to the ground.</li>
<li>The current bumper shape is a flat plate, it would be better if the bumper plate was curved. If the
curved bumper is given the right radius it would allow SCUTTLE to rotate in place after hitting
an obstacle without getting stuck. Obviously creating a curved bumper will increase construction
effort.</li>
</ul>
<p>The mechanical design of the bumper is only one part of the task. In order for SCUTTLE to be able
to respond to hitting an object I need to have have software that can respond to signals from the
limit switches and the appropriate electronics that transfers the limit switch state to the
raspberry pi. The electronics and the software that I created for this bumper will be described in
separate posts.</p>

                </div>
            </div>
        </div>
            </div>
        </div>

        <footer>
            <div id="footer" class="container">
    <div id="fbox1">
        <h2>Related</h2>
        <ul>
            <li><a href="https://github.com/pvandervelde"><i class="fa fa-github"></i> GitHub</a></li>
            <li><a href="https://www.linkedin.com/profile/view?id=33950311"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
            <li><a href="https://stackoverflow.com/users/539846/petrik"><i class="fa fa-stack-overflow"></i> StackOverflow</a></li>
            <li><a href="https://careers.stackoverflow.com/pvandervelde"><i class="fa fa-stack-overflow"></i> StackOverflow Careers</a></li>
            <li><a href="https://profile.codersrank.io/user/pvandervelde">CodersRank</a></li>
        </ul>
    </div>
    <div id="fbox2">
        <h2 id="copyright">Copyright</h2>
        <p>Copyright (c) 2022 <a href="/">Petrik van der Velde</a>. All rights reserved.</p>

        <h2 id="disclaimer">Disclaimer</h2>
        <p>The opinions expressed herein are my own personal opinions and do not represent my employer's view in any way.</p>
    </div>
    <div id="fbox3">
        <h2 id="media">Media</h2>
        <p><a href="/feed.atom"><img src="/assets/images/feed.png" alt="Atom feed"></a></p>
    </div>
</div>
<div id="copyright" class="container">
    <div>
        <p>
            Generated by <a href="https://wyam.io">Wyam</a> on Sun, 04 Dec 2022 03:15:55 GMT

 from commit <a href="https://github.com/pvandervelde/mindvortex/tree/f7160d19153ce6bd394bf5aeff7e31c8f9f5c8a9">f7160d19153ce6bd394bf5aeff7e31c8f9f5c8a9</a> at version 3.12.0.        </p>
    </div>

    <p>
        Site design based on the <a href="https://www.freecsstemplates.org/previews/opentools/">Open Tools</a> design
        by <a href="https://www.freecsstemplates.org">FreeCSSTemplates.org</a>.
    </p>
    <p>
        Feed icon by <a href="https://www.icojam.com/">Icojam</a> and Favicon by
        <a href="https://www.flaticon.com/free-icon/twister-sky-wind_12318" title="Yannick">Yannick</a>
        from <a href="https://www.flaticon.com" title="Flaticon">www.flaticon.com</a>
    </p>
</div>

        </footer>
    </body>
</html>
