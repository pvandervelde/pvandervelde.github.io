
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Mind vortex</title>
        <meta name="description" content="Welcome!" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link type="application/rss+xml" rel="alternate" title="Mind vortex" href="/feed.rss" />
        <link type="application/atom+xml" rel="alternate" title="Mind vortex" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/normalize.css" rel="stylesheet" />
        <link href="/assets/css/h5bp.css" rel="stylesheet">
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
        <link href="/assets/css/override.css" rel="stylesheet" />
        <link href="/assets/css/github.css" rel="stylesheet" type="text/css">


        <meta name="application-name" content="Mind vortex" />
        <meta name="msapplication-tooltip" content="Mind vortex" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Mind vortex" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://www.petrikvandervelde.nl/" />
        <!-- TODO: More social graph meta tags -->

        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>
        <script src="/assets/js/highlight.pack.js"></script>
        <script src="/assets/js/clean-blog.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="/assets/js/html5shiv.js"></script>
                <script src="/assets/js/respond.min.js"></script>
        <![endif]-->

        <!-- Our scripts -->
<script src="/assets/js/script.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DV643VJGFT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DV643VJGFT');
</script>


    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->
        <div id="header" class="container">
            <div id="logo">
                <h1><a href="/">Mind vortex</a></h1>
            </div>
            <div id="menu">
                <ul>
                            <!-- Pages -->
        <!-- BlogPosts -->
        <!-- Tags -->
        <!-- TagIndex -->
        <!-- BlogArchive -->
        <!-- Index -->
    <!-- Context.Documents['Pages'] -->
        <!-- 404 Not Found - False - /404 -->
        <!-- About - True - /about -->
        <!-- Calvinverse - False - /projects/calvinverse -->
        <!-- nBuildKit - False - /projects/nbuildkit -->
        <!-- Projects - True - /projects -->
        <!-- Scuttle - False - /projects/scuttle -->
            <li class="active" >
                Home
            </li>
            <li class="inactive" >
                <a href="/projects">Projects</a>
            </li>
            <li class="inactive" >
                <a href="/posts">Archive</a>
            </li>
            <li class="inactive" >
                <a href="/tags">Tags</a>
            </li>
            <li class="inactive" >
                <a href="/about">About</a>
            </li>

                </ul>
            </div>
        </div>

        <div id="page" class="container">
            <div id="sidebar">
                <div id="sbox1">
                    <h2>Patrick van der Velde</h2>

<p>
    <img src="https://www.gravatar.com/avatar/9bc8b3ff385cd14f2b12138c97729df2?s=160" alt="Gravatar for Patrick van der Velde">
</p>
<p>
    Dutch software developer who is living, working and playing in New Zealand.
    Rock climber and paragliding pilot. Developer of
    <a href="https://nbuildkit.github.io/nBuildKit.MsBuild/">nBuildKit</a>,
    <a href="https://github.com/Calvinverse">the Calvinverse resources</a> and other projects.
</p>
<p>
    <a href="/about.html">More ...</a>
</p>

                </div>
                <div id="sbox2">
                    <h2>Recent</h2>
                    <ul class="list-unstyled">
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-overview">Starting robotics - Building a bumper for scuttle. The overview</a></li>
                            <li><a href="/posts/Robotics-driving-scuttle-with-ros-gazebo-simulation">Starting robotics - Driving scuttle with ROS - Gazebo simulation</a></li>
                            <li><a href="/posts/Robotics-learning-ros">Starting robotics - Learning Robot Operating System (ROS)</a></li>
                            <li><a href="/posts/Starting-robotics-with-scuttle">Starting robotics with the SCUTTLE robot</a></li>
                            <li><a href="/posts/Building-autonomous-mobile-robot-why">Building an autonomous mobile robot - But why?</a></li>
                            <li><a href="/posts/Software-development-pipeline-security">Software development pipeline - Security</a></li>
                            <li><a href="/posts/Software-development-pipeline-infrastructure-dependency-reduction">Software development pipeline - Infrastructure dependency reduction</a></li>
                            <li><a href="/posts/Calvinverse-an-example-build-infrastructure">Calvinverse - An example build infrastructure</a></li>
                            <li><a href="/posts/On-prem-vs-cloud-build-systems">Software development pipeline - On-prem or in the cloud?</a></li>
                    </ul>
                </div>
                <div id="sbox3">
                    <h2>Tags</h2>
                    <div>
                        <ul class="list-unstyled">
                                <li>
                                    <a role="button" href="/tags/Sherlock" class="btn btn-default btn-sm"> Sherlock (13)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/nBuildKit" class="btn btn-default btn-sm"> nBuildKit (12)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Delivering-software" class="btn btn-default btn-sm"> Delivering software (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Software-development-pipeline" class="btn btn-default btn-sm"> Software development pipeline (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/DevOps" class="btn btn-default btn-sm"> DevOps (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/PG2" class="btn btn-default btn-sm"> PG2 (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Paragliding" class="btn btn-default btn-sm"> Paragliding (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Blog" class="btn btn-default btn-sm"> Blog (7)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Pipeline-design" class="btn btn-default btn-sm"> Pipeline design (6)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Robotics" class="btn btn-default btn-sm"> Robotics (6)</a>
                                </li>
                        </ul>
                    </div>
                    <br />
                    <ul class="pager">
                        <li class="next">
                            <a href="/tags">View All Tags &rarr;</a>
                        </li>
                    </ul>
                </div>
            </div>

            <div id="content">

        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, September 9, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my <a href="posts/Robotics-a-bumper-for-scuttle-overview">previous post</a> I talked about creating a bump
sensor for my SCUTTLE robot. After creating the mechanical design I started working on the software.
There are two parts to the software, translating the state of the micro switches and turning the state
changes into movement commands for the robot, i.e. if the robot runs into
an obstacle it should stop and reverse its last movement. I decided to create a
<a href="https://www.ros.org/">ROS</a> node for each of these actions, i.e. one node
for the movement generation and one to translate the switch states. The reason for
creating two nodes instead of putting all the code into one node is that this allows me to run the
movement generation code both in a simulation and on the physical robot. So I gain the ability to
test more of my code, but I lose a bit of performance because the two nodes communicate using
messages which is slower than just using method calls.</p>
<p>To test the bump sensor code I use <a href="https://gazebosim.org/home">Gazebo</a> to simulate how the bump
sensor would work. Gazebo has the ability to calculate collisions
and create <a href="http://docs.ros.org/en/api/gazebo_msgs/html/msg/ContactsState.html">ContactsState</a>
messages based on these collision calculations. So I created a third ROS node to translate these
Gazebo messages to my own <a href="https://github.com/pvandervelde/scuttle_ros_msgs/blob/noetic/msg/BumperEvent.msg">bumper event messages</a>.
With that I can test my obstacle response code in Gazebo which provides a more controlled environment
than the physical robot does.</p>
<p>The first thing to do is to update the robot definition to include the bumper. This is done by adding
the <a href="http://wiki.ros.org/urdf/XML/link">links</a> and <a href="http://wiki.ros.org/urdf/XML/joint">joints</a> that
make up my bumper to an <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/urdf/bumper.xacro">URDF file</a>.
This URDF file is linked to the main <a href="https://github.com/scuttlerobot/scuttle_description">model description</a>
for SCUTTLE. After that I added the information for the <a href="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins#Bumper">Gazebo bumper sensor</a>.
In the URDF file this looks as follows:</p>
<pre><code>    &lt;gazebo reference=&quot;front_bumper_plate_left_link&quot;&gt;
        &lt;sensor name=&quot;front_bumper_left&quot; type=&quot;contact&quot;&gt;
            &lt;selfCollide&gt;true&lt;/selfCollide&gt;
            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;
            &lt;updateRate&gt;15.0&lt;/updateRate&gt;
            &lt;material&gt;Gazebo/WhiteGlow&lt;/material&gt;
            &lt;contact&gt;
                &lt;collision&gt;base_link_fixed_joint_lump__front_bumper_plate_left_cl_collision_3&lt;/collision&gt;
                &lt;topic&gt;bumper_contact&lt;/topic&gt;
            &lt;/contact&gt;
            &lt;plugin name=&quot;gazebo_ros_bumper_controller_front_left&quot; filename=&quot;libgazebo_ros_bumper.so&quot;&gt;
                &lt;bumperTopicName&gt;scuttle_bumper&lt;/bumperTopicName&gt;
                &lt;frameName&gt;front_bumper_plate_left_link&lt;/frameName&gt;
            &lt;/plugin&gt;
        &lt;/sensor&gt;
    &lt;/gazebo&gt;
</code></pre>
<p>I found that defining a contact sensor for Gazebo requires getting the link ID correct. In order to
do so you need to follow these steps:</p>
<ul>
<li>The bumper contact information needs to be defined inside a <a href="https://classic.gazebosim.org/tutorials?tut=ros_urdf&amp;cat=connect_ros"><code>gazebo</code></a>
element. This <code>gazebo</code> element should have a <code>reference</code> attribute that points to the link that is
to be used as the bumper surface.</li>
<li>The name for the <code>collision</code> element needs to be found after translation to the SDF format. Normally
this is something Gazebo does internally. In this case you'll need to do this manually. If your
geometry is defined in an <a href="http://wiki.ros.org/xacro">xacro</a> file then you first need to translate
this to URDF using the <code>rosrun xacro xacro --inorder -o model.urdf model.urdf.xacro</code> command. After
that you can translate the URDF to SDF with the <code>gz sdf -p scuttle.urdf &gt; scuttle.sdf</code> command. Once
you have the SDF file you can search for the
<a href="https://answers.gazebosim.org/question/21992/what-collision-name-is-supposed-to-be-passed-to-contact-sensor/">correct element IDs</a>.</li>
</ul>
<p>In the above example the collision name, <code>base_link_fixed_joint_lump__front_bumper_plate_left_cl_collision_3</code>,
is the one you need to extract from the SDF file. Note that it can change if you make changes to
your xacro / URDF file, so in that case you will need to extract it again.</p>
<p>Once you have defined the URDF Gazebo will generate contact messages when the bumper hits an object.
These contact messages contain information describing where the contact occurred on the geometry mesh,
so in theory I could have used this information to determine if the contact would trigger the left
limit switch or the right limit switch or both. However that requires a decent amount of calculations
which is both work and introduces the potential for errors. So I opted to split the bumper into
two parts, one for the left side and one for the right side. If anything contacts anywhere on the
left side I consider that a trigger for the left part of the bumper and similar for the right side.</p>
<figure style="float:left">
<img alt="SCUTTLE with bumper in RViz" src="/assets/images/robotics/scuttle/scuttle-with-bumper-in-rviz.png" />
<figcaption>SCUTTLE with bumper in RViz</figcaption>
</figure>
<p>With the URDF work done I started writing the code for the different ROS nodes. First
the <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/gazebo_contact_sensor_translator.py">gazebo translator node</a>.
This node subscribes to the <a href="http://docs.ros.org/en/api/gazebo_msgs/html/msg/ContactsState.html">ContactsState</a>
messages that Gazebo sends when the bumper geometry collides with something. These messages are then
translated to a <a href="https://github.com/pvandervelde/scuttle_ros_msgs/blob/noetic/msg/BumperEvent.msg">BumperEvent</a>
message for further processing.</p>
<p>One interesting observation about the Gazebo contact messages are that they exhibit something
similar to <a href="https://www.pcmag.com/index.php/encyclopedia/term/switch-bounce">switch bounce</a>, in other
words it seems that the contact is intermittent even if the bumper plate is in solid contact with
the object. I'm guessing that this is caused by the fact that calculating collisions between moving
surfaces is difficult. In the end it doesn't matter what causes this behaviour though because we
need to <a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/debounce.py">deal with it</a> in
some sensible way.</p>
<p>Once the bumper event messages have been generated they are processed by the
<a href="https://github.com/pvandervelde/scuttle_bumper/blob/master/src/bumper_navigator.py">second node</a>.
This node subscribes to both odometry events and bumper events. Internally it keeps track of the
motion state of SCUTTLE. On reception of a bumper event the node sends a
<a href="http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html">velocity command</a>
to stop the robot. Once the robot has stopped it sends commands for it to reverse course far enough
that it is no longer contact with the obstacle.</p>
<p>One thing to note is that while the bumper code is working to reverse course after hitting an obstacle,
the other parts of ROS, e.g. the navigation stack, are probably still trying to steer the robot in the
original direction because those parts don't know about the obstacle. After all it is not on the
navigation map. This results in many different velocity commands being send, which could be very
confusing for the robot. One design decision was to make the bumper code unaware of other nodes. This
was done because allowing the bumper code to supress velocity
commands from other nodes would imply that the bumper code is always the most important publisher
when it comes to velocity commands. There are cases where this isn't true, e.g. when using
the bumpers to park SCUTTLE against a specific object like in the case of a docking station.</p>
<p>To ensure that a consistent set of velocity commands are sent to the motors I used the
<a href="http://wiki.ros.org/twist_mux">twist multiplexer node</a> which takes in velocity commands from
many nodes and forwards them using a priority-based scheme. In the current implementation the
priorities are, from low to high</p>
<ul>
<li>Navigation</li>
<li>Keyboard</li>
<li>Bumper</li>
<li>Joypad / Joystick</li>
</ul>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/SddexyGTJ0M"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe>
<p>By using the twist multiplexer mode it is easy for users to change the priority by changing a configuration
file instead of having to change the bumper code.</p>
<p>With that the bumper code is able to make SCUTTLE respond to objects it bumps into. The next step in
the process of adding bump sensors to SCUTTLE is to assemble the electronic components so that the
movement of the bumper can be registered and reported to the software components.</p>
<p>Finally a addition to the software that needs to be made is the ability to add the obstacles in the
navigation map so that SCUTTLE can navigate around the newly discovered obstacles.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-a-bumper-for-scuttle-overview">Starting robotics - Building a bumper for scuttle. The overview</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Saturday, August 27, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In order to allow my SCUTTLE robot to drive around autonomously it needs some sensors so that it
can <a href="https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping">perceive its surroundings</a>.
One of the ways in which this is normally achieved is by adding a <a href="https://en.wikipedia.org/wiki/Lidar">LIDAR</a>
unit. Unfortunately I don't have one of those, and LIDAR units are relatively expensive in New Zealand.
Additionally I figured I'd learn more about robot sensors if I set up some simple sensors for my
SCUTTLE robot before getting a LIDAR.</p>
<figure style="float:left">
<img alt="CAD model of the SCUTTLE bumper" src="/assets/images/robotics/scuttle/scuttle-bumper-cad-model.png" />
<figcaption>The CAD model of the SCUTTLE bumper</figcaption>
</figure>
<p>So I decided to start with the simplest kind of sensor, the bump sensor. This type of sensor
consists of one or more <a href="https://en.wikipedia.org/wiki/Limit_switch">limit switches</a> and a bumper
surface, i.e. some kind of plate that bumps into things. This plate is held in place by springs thereby
giving it the ability to move while also returning to its original position.
When the robot bumps into an object with the plate, the springs are compressed and the plate hits
the limit switches. These switches then signal the robot that it has hit something. At that point the
robot can stop its motion and back away from the obstacle. As the robot backs away the springs push the
bumper plate away from the limit switches. The change in switch state then signals to the robot that
it is no longer in contact with the obstacle and can thus continue on its journey.</p>
<p>Overall this doesn't sound very complicated so it should be pretty quick and easy to build the
bump sensor ...</p>
<p>Several weeks down the line I nearly finished my bump sensors</p>
<p>The first part of my build was the design of the physical parts that I need to attach to SCUTTLE. I
build the bumper with simple parts because I don't have access to a workshop or a 3D printer. So
the bumper is a UHMWPE plate reinforced by some 90 degree aluminium extrusions. This prevents the
plate from flexing when it contacts an obstacle. The plate is attached to two angle brackets, one on
the left side and one on the right side. It is attached using four M3 bolts wrapped with springs,
2 bolts for each side. The idea behind using 2 bolts per side is that this should provide some
rotational stability while keeping the construction simple. Finally the angle brackets is attached
to the scuttle frame with two T slot nuts.</p>
<p>I found that the springs that keep the plate in the extended position have to be quite soft, otherwise
SCUTTLE won't be able to compress the springs when it hits something at low speed. The first
set of springs I got from Amazon were too stiff. For the second set of springs I got some ballpoint
pen springs of Aliexpress which are much less stiff.</p>
<figure style="float:right">
<img alt="SCUTTLE with its new bumper" src="/assets/images/robotics/scuttle/scuttle-with-bumper.jpg" />
<figcaption>SCUTTLE with its new bumper</figcaption>
</figure>
<p>This first version of the bumper mechanics works relatively well but for the next version there
are some things I want to change</p>
<ul>
<li>The bolts have full thread on them which sometimes causes the bolts to get hung up on the tread. I
had some issues finding partially threaded bolts with the right length and diameter.</li>
<li>The current design allows left to right tilt which is good, but also top to bottom tilt. The latter
is not so good as it potentially allows SCUTTLE to hit an obstacle without noticing. A better design
would allow left to right rotation of the bumper but little to no top to bottom rotation. This
allows the left and right limit switches to be triggered individually when SCUTTLE hits an obstacle
on the left or right side respectively while ensuring that the limit switches are always triggered
if the bumper hits something, even if the obstacle is low to the ground.</li>
<li>The current bumper shape is a flat plate, it would be better if the bumper plate was curved. If the
curved bumper is given the right radius it would allow SCUTTLE to rotate in place after hitting
an obstacle without getting stuck. Obviously creating a curved bumper will increase construction
effort.</li>
</ul>
<p>The mechanical design of the bumper is only one part of the task. In order for SCUTTLE to be able
to respond to hitting an object I need to have have software that can respond to signals from the
limit switches and the appropriate electronics that transfers the limit switch state to the
raspberry pi. The electronics and the software that I created for this bumper will be described in
separate posts.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-driving-scuttle-with-ros-gazebo-simulation">Starting robotics - Driving scuttle with ROS - Gazebo simulation</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Wednesday, June 1, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>After getting familiar with <a href="posts/Robotics-learning-ros">ROS</a>, the next step was to get the
navigation stack working in Gazebo for the SCUTTLE robot. Fortunately, the SCUTTLE developers
had already created a number of ROS packages containing the
<a href="https://github.com/scuttlerobot/scuttle_description">scuttle model</a>,
<a href="https://github.com/scuttlerobot/scuttle_bringup">the startup scripts</a> and the
<a href="https://github.com/scuttlerobot/scuttle_driver">driver code</a>. All the bits you need to drive SCUTTLE
around using ROS.</p>
<p>The first challenge is to drive the SCUTTLE model around in <a href="https://gazebosim.org/">Gazebo</a>
using the <a href="http://wiki.ros.org/teleop_twist_keyboard">keyboard</a>.
This was easily achieved using Gazebo and RViz using WSL2, but it was a bit slow.</p>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/TI9tfzn8yXE"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
</iframe>
<p>The next challenge was to make the virtual SCUTTLE drive to a specific point using a custom
ROS node. While doing the <a href="https://www.udemy.com/course/ros-essentials/">ROS for beginners I</a> course
I wrote some code to do a move-to-goal for the <a href="http://wiki.ros.org/turtlesim">turtlesim</a> virtual
robot. The <a href="https://gist.github.com/pvandervelde/35200cce52d416d899c3db600c98a4a5">code</a> was updated
and then used for the SCUTTLE robot. The result is a robot that moves to a goal, mission accomplished!</p>
<p>The final challenge, for now at least, is to get the navigation stack to work for SCUTTLE. In order
to do so a few new packages needed to be created. The packages I created are</p>
<ul>
<li><a href="https://github.com/scuttlerobot/scuttle_slam">scuttle_slam</a> - Contains the configurations and
launch files for running <a href="http://wiki.ros.org/gmapping">gmapping</a> SLAM using the SCUTTLE LIDAR.</li>
<li><a href="https://github.com/scuttlerobot/scuttle_navigation">scuttle_navigation</a> - Contains the
configuration for working with the <a href="http://wiki.ros.org/navigation">navigation stack</a>.</li>
<li><a href="https://github.com/scuttlerobot/scuttle_gazebo">scuttle_gazebo</a> - Contains a number of Gazebo
worlds for testing our virtual SCUTTLE.</li>
</ul>
<p>The <code>scuttle_slam</code> and <code>scuttle_navigation</code> packages are based on the similar packages for
<a href="https://github.com/ROBOTIS-GIT/turtlebot3">turtlebot3</a> with adjustments so that the configuration
matches SCUTTLE's performance.</p>
<p>For navigation in ROS1, you need two different types of path planners and a map for each planner. The
first type is the global planner, which uses a map to determine the fastest path from the current
location to the goal location. The second type, called the local planner, navigates the robot to
the goal by trying to follow the path created by the global planner. The path followed by the local
planner may deviate from the global path due to previously unknown obstacles and limitations of the
robot, e.g. the ability to follow a turn. The map for each planner is known as a <a href="http://wiki.ros.org/costmap_2d">costmap</a>
which indicates which part of the surroundings are occupied by obstacles and which parts can be
navigated. After configuring the planners and the costmaps, the navigation worked. I could use
RViz to set a point on the map and the virtual SCUTTLE would navigate to that location automatically.
Success!</p>
<figure style="float:left">
<img alt="Scuttle navigating in RViz" src="/assets/images/robotics/scuttle/scuttle-navigate-in-rviz.png" />
<figcaption>SCUTTLE robot navigating a room in RViz</figcaption>
</figure>
<p>Now, not everything was fine. The <a href="https://answers.ros.org/question/397737/dwa-local-planner-cant-find-a-trajectory-unless-rotate-recovery-runs">first issue</a>
is some weird behaviour with the <a href="http://wiki.ros.org/dwa_local_planner?distro=noetic">DWA local planner</a>.
Once the robot is moving the local planner mostly does a good job. However, when starting a path it
takes a while for the local planner to pick up the global path. In fact, the DWA planner doesn't seem
to <a href="https://www.youtube.com/watch?v=Nt9XyJHzfas&amp;ab_channel=PatrickvanderVelde">accept the global plan</a>
until after a <a href="http://wiki.ros.org/rotate_recovery?distro=noetic">rotate recovery</a> has taken place.
So far, I haven't found a solution to this problem.</p>
<p>The second issue is that, in some cases, the navigation stack fails to find a path out of a narrow
hallway or though a narrow door. In general, this happens when exploring a location, e.g. using the
<a href="http://wiki.ros.org/explore_lite">explore_lite</a> package. It seems that the algorithm
can't find a turn that will rotate the robot in the available space, even though scuttle is
able to perform in-place rotations. At the start of a navigation exercise, in-place rotations are
gladly used. However once the robot is on the move, the algorithm doesn't seem to apply in-place
rotations anymore.</p>
<p>Finally, you have to keep in mind that the default planners for ROS are path planners. This means that
they plan a path from the start to the destination. These paths, however, only describe the direction
a robot should take at a given location. They don't describe velocity or acceleration. Only
describing the direction can generate paths with abrupt turns that force the robot to slow
down significantly. Using a trajectory planner, which at least prescribes velocities, makes for a
smoother experience for robot and cargo.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Robotics-learning-ros">Starting robotics - Learning Robot Operating System (ROS)</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Tuesday, May 3, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/ROS" class="btn btn-default btn-xs tag-no-wrap">ROS</a>
                        <a id="post-category" role="button" href="/tags/ROS-Noetic" class="btn btn-default btn-xs tag-no-wrap">ROS&nbsp;Noetic</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>As part of my <a href="tags/Robotics">journey into robotics</a> I have been working on updating my
<a href="https://www.scuttlerobot.org/">SCUTTLE robot</a> to use the
<a href="http://wiki.ros.org/">Robot Operating System (ROS)</a>. ROS provides a number of different things
that make robot development much easier. The main items are a middleware layer for communication
between different parts of the robot, hardware abstractions for different sensors, motors and
controllers, device drivers and many other libraries and packages.</p>
<p>The main benefit of using ROS is that it provides a lot of integrations and functionality that you
can quickly use. On the other hand the drawback that comes with all of this is that the learning curve
for ROS is very steep. The documentation is pretty good and so are the tutorials, however there are
a lot of different parts in ROS, which makes for a lot of interesting ways to get confused. So to
speed up my progress with ROS I decided to do the <a href="https://www.udemy.com/course/ros-essentials/">ROS for beginners I</a>
and <a href="https://www.udemy.com/course/ros-navigation/">II courses</a> on Udemy. These courses were very helpful
to reduce the learning curve for ROS and quickly get me familiar with ROS.</p>
<figure style="float:left">
<img alt="Scuttle in Gazebo" src="/assets/images/robotics/scuttle/scuttle-in-gazebo.jpg" />
<figcaption>SCUTTLE robot in Gazebo</figcaption>
</figure>
<p>This post won't explain how ROS works, there are
<a href="https://www.google.com/search?q=getting+started+with+ros&amp;rlz=1C1CHBF_enNZ825NZ825&amp;oq=getting+started+with+ros&amp;aqs=chrome..69i57j69i61.2633j0j7&amp;sourceid=chrome&amp;ie=UTF-8">many, many, many tutorials out on the web</a>
that will do a far better job than I can. However I do want to share some of the things I learned
from working with ROS.</p>
<p>The first thing to note is the operating system on which you want to run ROS. ROS is developed
to be run on Ubuntu. My home PC runs on the Windows Operating System. ROS 1 wasn't designed to run
directly on Windows (ROS2 will be able to) but there are several ways to run it. First you can run
ROS Noetic straight on Windows using <a href="https://robostack.github.io/">Robostack</a>. This uses the Conda
package manager and provides packages for all operating systems. I found that this works moderately
well, there are a number of packages missing and occasionally things error out. This approach works
well for simple learning exercises but may yet not be suitable for large ROS applications.</p>
<p>A second approach is to <a href="https://ishkapoor.medium.com/how-to-install-ros-noetic-on-wsl2-9bbe6c00b89a">run ROS on WSL2</a>.
This is able to run the Ubuntu native packages so you can run all parts of ROS and with the help of
an XServer like <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a> you can even run all the graphical
tools. One thing to keep in mind if you use WSL is that networking may cause problems if you run
ROS distributed over more than one computing device, e.g. a laptop and a physical robot. With WSL
there is no easy way to expose WSL applications to uninitiated network connections, i.e.
a request started from inside WSL works, but a request started from outside WSL won't be able to
connect. This is important because ROS nodes need to be able to communicate with each other freely.
The result will be that the nodes on the WSL side will seem to be connected and functional while the
other nodes won't be able to send messages to the WSL nodes.</p>
<p>The final approach to running ROS is to create an <a href="https://gist.github.com/pvandervelde/2282dafc080945ecb7981edb740ed47c">Ubuntu VM</a>
or physical machine. In this case as long as the machine is reachable over the network for other
compute devices, it is possible to run ROS distributed over the network. This is the way I currently
run ROS.</p>
<figure style="float:right">
<img alt="Scuttle in RViz" src="/assets/images/robotics/scuttle/scuttle-in-rviz-no-sensors.jpg" />
<figcaption>SCUTTLE robot in RViz</figcaption>
</figure>
<p>Once you have a working ROS installation the next thing you'll find out is that ROS configurations
can be difficult to get right, especially when you're working with a physical robot where visibility
of what is going on may not be the best. There are a number of useful tools available to provide
insights into what is going on with your robot.</p>
<p>The first tool is <a href="https://gazebosim.org/">Gazebo</a> which provides a simulated environment for
ROS robots. The simulation is based on a physics engine with good accuracy of real world physics. It
also provides models for sensors, like LIDAR and cameras, and sensor noise to simulate real-world
sensor behaviour. Having a simulated environment allows you to repeat behaviours many times in
the same way in rapid succession. Having a way to easily repeat behaviours and control the environment
means that you can quickly test and debug specific behaviours, something which can be much more difficult
with a physical robot.</p>
<p>The second tool, <a href="http://wiki.ros.org/rviz">RViz</a>, provides visualization of the environment of the
robot and how the robot perceives that environment. It allows you to visualize what the robot can
&lsquo;see&rsquo;. RViz works by subscribing to the different message topics that are available. This means
it works both for simulated robots (using Gazebo) and physical robots.</p>
<p>The final tool worth discussing is <a href="https://foxglove.dev/">Foxglove studio</a> which also provides
insight into the data that the robot generates, both from sensors but also in the form of messages
sent between the different components of the robot. One of the nice features of Foxglove is that
you can make plots with values provided by messages. For instance you can plot the velocity
components of a <a href="http://docs.ros.org/en/lunar/api/geometry_msgs/html/msg/Twist.html">Twist message</a>.
This is useful to compare requested velocities compared to actual achieved velocities.
Another great feature of Foxglove is that it is able to display the <a href="http://wiki.ros.org/rosout">ROS logs</a>
and it also allows you to filter and search these logs. Given that ROS logs can quickly become
large the ability to filter is very useful.</p>
<figure style="float:left">
<img alt="Scuttle in RViz with LIDAR overlay" src="/assets/images/robotics/scuttle/scuttle-in-rviz-slam-enabled.jpg" />
<figcaption>SCUTTLE robot in RViz with LIDAR overlay</figcaption>
</figure>
<p>When working with a mobile robot, like I am, getting the robot to navigate a space is often one of
the first achievable goals. The <a href="http://wiki.ros.org/navigation">navigation stack</a> in ROS provides
a lot of the basic capabilities to get started with robot navigation in a reasonable time span. Do
note however that the navigation stack in ROS is fairly large and has a lot of different configuration
options so it is wise to set some time aside for learning about the different options. I'll talk about
navigating with SCUTTLE in a future post.</p>
<p>As mentioned I started learning ROS1 with Udemy. My goal for learning ROS was to use it for
navigation with my SCUTTLE  robot, more on that in a future post. Once I manage to get navigation
working for SCUTTLE I plan to start adding different sensors. Finally I want to enable task planning
for SCUTTLE, e.g. tasks like &ldquo;drive to the living room and collect my coffee cup and bring it back
to me&rdquo;.</p>
<p>Another part of my plans is to upgrade to using <a href="https://docs.ros.org/en/galactic/index.html">ROS2</a>.
ROS1 end-of-life is 2025, which is only 3 years away, and additionally ROS2 has a more modern stack
with python 3, better communication security, an improved navigation stack and more active development.
More on this will follow in a future post once I have upgraded my robot to ROS2</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Starting-robotics-with-scuttle">Starting robotics with the SCUTTLE robot</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, March 18, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Scuttle" class="btn btn-default btn-xs tag-no-wrap">Scuttle</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>As mentioned in my last post I have started tinkering with mobile robots. My current goal is to
build an outdoor capable <a href="https://en.wikipedia.org/wiki/Autonomous_robot">autonomous mobile robot</a>.
The first problem I have to solve in order to move towards my goal is that I know a decent amount
about software, a reasonable amount about structures and mechanics and very little about electronics.
Oh and I know nothing about the robotics algorithms like how navigation works, the fact that robots
may have a hard time
<a href="https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping">figuring out where they are</a>
and that decision making is hard for robots.</p>
<p>So in order to not have to learn all the things at the same time I decided it would be sensible to
start off buying a kit that I could assemble and learn to work with. The basic requirements were</p>
<ul>
<li>Something that didn't require me to solder electronics or 3d print parts, because I have neither
of those tools, yet ...</li>
<li>Capable of actually carrying a load of some sort. Most robot kits are fun platforms to play with
but other than driving around they're not actually capable of carrying things. I want my robot to
be able to carry things for me.</li>
<li>With accessible hardware and software so that I could modify and extend it.</li>
<li>Affordable, because money is still finite</li>
</ul>
<figure style="float:right">
<img alt="Scuttle assembled" src="/assets/images/robotics/scuttle/scuttle-assembled.jpg" />
<figcaption>SCUTTLE robot assembled</figcaption>
</figure>
<p>After a little bit of searching I decided to buy the <a href="https://scuttlerobot.org/">SCUTTLE robot</a> kit.
The SCUTTLE kit is an <a href="https://github.com/scuttlerobot">open source kit</a> for which all the build
information is available online, from the <a href="https://grabcad.com/library/scuttle-robot-v2-3-1">3D drawings</a>
to the material BOM. Additionally there is a lot of sample code that makes it easy to get going with
the robot. There are code samples that allow you to drive the robot with a gamepad or by putting it in
follow mode where it follows a coloured object. Note that when you pick a coloured object apparently
orange is the best colour because of the colour difference with the surroundings. In my case initially
I picked a dark red object in a poorly lit environment with lots of other variations of red around.
You can probably imagine how well that went ...&hellip; [*]</p>
<p>Assembly of the SCUTTLE robot is pretty easy, it consists of aluminium T-slot lengths, some 3D
printed parts and some electronics parts. The T-slot lengths are fastened with angle brackets and
the 3D printed parts bolt to the T-slot lengths. The kit I bought only required connecting electronic parts
with connectors, no soldering required. If you build a SCUTTLE from scratch there is some soldering to
be done.</p>
<p>Once you have assembled your SCUTTLE you can test the functionality by using the code samples to
verify the encoders and the motors. Note that it is wise to review your cabling before turning anything
on because it is possible to connect some of the electronics incorrectly. I ended up breaking my
Raspberry Pi, quite possibly by connecting the encoders backwards or something similar.</p>
<figure style="float:left">
<img alt="Scuttle in RViz" src="/assets/images/robotics/scuttle/scuttle-rviz.png" />
<figcaption>SCUTTLE in RViz</figcaption>
</figure>
<p>After verifying that the motors rotate in the correct direction you can try controlling the
robot via the gamepad and drive it around the house.</p>
<p>Currently I'm working to update my SCUTTLE with the <a href="https://www.ros.org/">ROS</a> software. Currently
I'm testing with ROS noetic but I am looking to eventually switch to using ROS2 as it seems to have
a more flexible navigation stack. More on that in a future post.</p>
<p>I'm also planning to add some sensors to my SCUTTLE to make it a bit more autonomous. The first
plan is to add a bumper that will tell the robot if it has hit something. I have picked up some
contact switches but am still thinking about the design for the bumper. Later on I want to add
sonar, <a href="https://en.wikipedia.org/wiki/Time-of-flight_camera">Time of Flight (ToF) sensors</a> and
potentially cameras as well.</p>
<p>[*] SCUTTLE drove straight at the red coloured couch instead of following the red object I wanted
it to follow</p>

                </div>
            </div>
        </div>
            </div>
        </div>

        <footer>
            <div id="footer" class="container">
    <div id="fbox1">
        <h2>Related</h2>
        <ul>
            <li><a href="https://github.com/pvandervelde"><i class="fa fa-github"></i> GitHub</a></li>
            <li><a href="https://www.linkedin.com/profile/view?id=33950311"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
            <li><a href="https://stackoverflow.com/users/539846/petrik"><i class="fa fa-stack-overflow"></i> StackOverflow</a></li>
            <li><a href="https://careers.stackoverflow.com/pvandervelde"><i class="fa fa-stack-overflow"></i> StackOverflow Careers</a></li>
            <li><a href="https://profile.codersrank.io/user/pvandervelde">CodersRank</a></li>
        </ul>
    </div>
    <div id="fbox2">
        <h2 id="copyright">Copyright</h2>
        <p>Copyright (c) 2022 <a href="/">Petrik van der Velde</a>. All rights reserved.</p>

        <h2 id="disclaimer">Disclaimer</h2>
        <p>The opinions expressed herein are my own personal opinions and do not represent my employer's view in any way.</p>
    </div>
    <div id="fbox3">
        <h2 id="media">Media</h2>
        <p><a href="/feed.atom"><img src="/assets/images/feed.png" alt="Atom feed"></a></p>
    </div>
</div>
<div id="copyright" class="container">
    <div>
        <p>
            Generated by <a href="https://wyam.io">Wyam</a> on Fri, 09 Sep 2022 07:16:50 GMT

 from commit <a href="https://github.com/pvandervelde/mindvortex/tree/62fc793f8eacf7a47644801d34c14b43863dc285">62fc793f8eacf7a47644801d34c14b43863dc285</a> at version 3.9.0.        </p>
    </div>

    <p>
        Site design based on the <a href="https://www.freecsstemplates.org/previews/opentools/">Open Tools</a> design
        by <a href="https://www.freecsstemplates.org">FreeCSSTemplates.org</a>.
    </p>
    <p>
        Feed icon by <a href="https://www.icojam.com/">Icojam</a> and Favicon by
        <a href="https://www.flaticon.com/free-icon/twister-sky-wind_12318" title="Yannick">Yannick</a>
        from <a href="https://www.flaticon.com" title="Flaticon">www.flaticon.com</a>
    </p>
</div>

        </footer>
    </body>
</html>
