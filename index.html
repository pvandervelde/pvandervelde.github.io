
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Mind vortex</title>
        <meta name="description" content="Welcome!" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link type="application/rss+xml" rel="alternate" title="Mind vortex" href="/feed.rss" />
        <link type="application/atom+xml" rel="alternate" title="Mind vortex" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/normalize.css" rel="stylesheet" />
        <link href="/assets/css/h5bp.css" rel="stylesheet">
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
        <link href="/assets/css/override.css" rel="stylesheet" />
        <link href="/assets/css/github.css" rel="stylesheet" type="text/css">


        <meta name="application-name" content="Mind vortex" />
        <meta name="msapplication-tooltip" content="Mind vortex" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Mind vortex" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://www.petrikvandervelde.nl/" />
        <!-- TODO: More social graph meta tags -->

        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>
        <script src="/assets/js/highlight.pack.js"></script>
        <script src="/assets/js/clean-blog.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="/assets/js/html5shiv.js"></script>
                <script src="/assets/js/respond.min.js"></script>
        <![endif]-->

        <!-- Our scripts -->
<script src="/assets/js/script.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DV643VJGFT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DV643VJGFT');
</script>


    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->
        <div id="header" class="container">
            <div id="logo">
                <h1><a href="/">Mind vortex</a></h1>
            </div>
            <div id="menu">
                <ul>
                            <!-- Pages -->
        <!-- BlogPosts -->
        <!-- Tags -->
        <!-- TagIndex -->
        <!-- BlogArchive -->
        <!-- Index -->
    <!-- Context.Documents['Pages'] -->
        <!-- 404 Not Found - False - /404 -->
        <!-- About - True - /about -->
        <!-- Projects - True - /projects -->
        <!-- Robotics - False - /projects/robotics -->
        <!-- Scuttle - False - /projects/scuttle -->
            <li class="active" >
                Home
            </li>
            <li class="inactive" >
                <a href="/projects">Projects</a>
            </li>
            <li class="inactive" >
                <a href="/posts">Archive</a>
            </li>
            <li class="inactive" >
                <a href="/tags">Tags</a>
            </li>
            <li class="inactive" >
                <a href="/about">About</a>
            </li>

                </ul>
            </div>
        </div>

        <div id="page" class="container">
            <div id="sidebar">
                <div id="sbox1">
                    <h2>Patrick van der Velde</h2>

<p>
    <img src="https://www.gravatar.com/avatar/9bc8b3ff385cd14f2b12138c97729df2?s=160" alt="Gravatar for Patrick van der Velde">
</p>
<p>
    Dutch software developer who is living, working and playing in New Zealand.
    Rock climber and paragliding pilot. Developer of
    <a href="https://nbuildkit.github.io/nBuildKit.MsBuild/">nBuildKit</a>,
    <a href="https://github.com/Calvinverse">the Calvinverse resources</a> and other projects.
</p>
<p>
    <a href="/about.html">More ...</a>
</p>

                </div>
                <div id="sbox2">
                    <h2>Recent</h2>
                    <ul class="list-unstyled">
                            <li><a href="/posts/Swerve-drive-control-animations">Swerve drive - Movement animations</a></li>
                            <li><a href="/posts/Swerve-drive-body-focussed-control">Swerve drive - Better movement by controlling the body motions</a></li>
                            <li><a href="/posts/Swerve-drive-kinematics-verification">Swerve drive - Verification of the kinematics solution</a></li>
                            <li><a href="/posts/Swerve-drive-kinematics-simulation">Swerve drive - Kinematics simulation</a></li>
                            <li><a href="/posts/Swerve-drive-introduction">Swerve drive - Moving a robot in all directions, mostly</a></li>
                            <li><a href="/posts/Robotics-fixing-scuttles-encoder">Starting robotics - Fixing the wheel encoders</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-electronics">Starting robotics - Building a bumper for scuttle. The electronics</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-software">Starting robotics - Building a bumper for scuttle. The software</a></li>
                            <li><a href="/posts/Robotics-a-bumper-for-scuttle-overview">Starting robotics - Building a bumper for scuttle. The overview</a></li>
                            <li><a href="/posts/Robotics-driving-scuttle-with-ros-gazebo-simulation">Starting robotics - Driving scuttle with ROS - Gazebo simulation</a></li>
                    </ul>
                </div>
                <div id="sbox3">
                    <h2>Tags</h2>
                    <div>
                        <ul class="list-unstyled">
                                <li>
                                    <a role="button" href="/tags/Robotics" class="btn btn-default btn-sm"> Robotics (13)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Sherlock" class="btn btn-default btn-sm"> Sherlock (13)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/nBuildKit" class="btn btn-default btn-sm"> nBuildKit (12)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/DevOps" class="btn btn-default btn-sm"> DevOps (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Delivering-software" class="btn btn-default btn-sm"> Delivering software (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Software-development-pipeline" class="btn btn-default btn-sm"> Software development pipeline (11)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/PG2" class="btn btn-default btn-sm"> PG2 (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Paragliding" class="btn btn-default btn-sm"> Paragliding (9)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Blog" class="btn btn-default btn-sm"> Blog (7)</a>
                                </li>
                                <li>
                                    <a role="button" href="/tags/Nuclei" class="btn btn-default btn-sm"> Nuclei (6)</a>
                                </li>
                        </ul>
                    </div>
                    <br />
                    <ul class="pager">
                        <li class="next">
                            <a href="/tags">View All Tags &rarr;</a>
                        </li>
                    </ul>
                </div>
            </div>

            <div id="content">

        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-control-animations">Swerve drive - Movement animations</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Tuesday, July 4, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my last two posts I talked about different control methods for a swerve drive robot. One method
controls the movement of drive modules directly. The other method controls the movement of
the body and derives the desired state for the drive modules from that.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation"
        src="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>Simulation data for a 45 degree linear track that transitions to an in-place rotation.</figcaption>
</figure>
<p>To see the difference between these control methods my simulation code created all kinds of interesting
plots like the ones above. However I was still having trouble visualizing what was actually happening,
especially in the case of the movement of the Instantaneous Centre of Rotation (ICR), i.e. the
rotation point for the robot at a given point in time. The lower left graph shows the paths the
ICR for different combinations of drive modules. While it looks pretty it does not make a lot of
sense to me.</p>
<iframe
    style="float:left"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/LlyopmLMlZY"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>So to address that issue I updated the simulation code to produce some <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/a83c0d8ce4cc3096548be51244ec0a40d2a7db8f/sim_output/animate.py">animations</a>
that display the position of the robot and the wheels as well as a number of plots for the state of
the robot body and the drive modules. To create the animations I used the
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html#matplotlib.animation.FuncAnimation">FuncAnimation class</a>
that is available in matplotlib. The animations can then either be turned into an HTML page with
animation controls using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.HTMLWriter.html">HTMLWriter</a>,
or into MP4 video files using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FFMpegWriter.html">FFMpegWriter</a>.
In order to get reasonable performance when using the animation functions in matplotlib it is important
to update the plots instead of drawing new ones. This can be done using the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D.set_data">set_data</a>
function, for instance for updating the position of the <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/a83c0d8ce4cc3096548be51244ec0a40d2a7db8f/sim_output/animate.py#L784">robot body</a>.
It is good to keep in mind that even with this performance improvement the creation of the animations
isn't very fast for our robot simulation because a large number of image frames need to be made. For
the 6 second movement in the animation anywhere between 150 and 600 frames need to be created.</p>
<p>The animation above shows how the robot behaves when using the
<a href="posts/Swerve-drive-kinematics-simulation">direct module controller</a>. As you can see in the video different
pairs of wheels have different rotation points, signified by the red dots. As the movement progresses
these rotation points have quite a large range of motion. This indicates that the wheels are not
synchronized and most likely some of the wheels are slipping.</p>
<iframe
    style="float:right"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/U6Z_meFKNrI"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
</iframe>
<p>I created another animation for the same situation but with the
<a href="posts/Swerve-drive-body-focussed-control">body oriented controller</a>. In this case the rotation points
are all in a single location leading me to conclude that all the wheels are synchronized and little
to no wheel slip is occurring.</p>
<p>One other interesting thing you can see in the video is that the acceleration and
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)">jerk</a> values change very abruptly. In real life this
would lead to significant loads on the robot and its drive system. In the simulation this behaviour
is due to the fact that linear profile that is being used to transition from one state to another.
As mentioned before the next improvement will be to replace this linear interpolation with a control
approach that will provide <a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">smooth transitions</a>
for velocity and accelerations.</p>
<h4>Edits</h4>
<ul>
<li>July 6th 2023: Added a section discussing the use of the matplotlib animation functions.</li>
</ul>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-body-focussed-control">Swerve drive - Better movement by controlling the body motions</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, June 9, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>In my <a href="posts/Swerve-drive-kinematics-simulation">first attempt</a> to model a swerve drive I controlled
the movement of the robot by directly providing commands to the individual drive modules, i.e. by
controlling the steering angle and the wheel velocity of each of the four drive modules. Additionally
I assumed that the transition from one state (steering angle, wheel velocity) to another state would
follow a linear profile. An example of this can be seen in the graphs below. The bottom left graph shows
the linear change in steering angle for the four drive modules. It should be noted that a linear
profile isn't very realistic as this requires the motors to be capable of instant changes in velocity
and acceleration. However making this assumption keeps the calculations simple. At a later stage I
will be encoding different movement profiles amongst which a low
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)">jerk</a> profile for smooth movements.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation with a module-first control algorithm"
        src="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Simulation data for a 45 degree linear track that transitions to an in-place rotation with a
    module-first control algorithm.
  </figcaption>
</figure>
<p>The benefit of controlling the robot by directly controlling the drive modules is that the control
algorithm is very simple and all movement patterns are possible. For instance it is possible to make
all the wheels change steering angle without moving the robot body, something which is not possible
with indirect control methods.</p>
<p>However there are also a number of drawbacks. The main one is that
for a swerve drive to be efficient the motions of the different drive modules need to be synchronized.
That means that all the drive modules needs to be controlled so that none of the wheels slip along
the surface. For simple linear or rotational movements of the robot body this is easy to achieve but
for complicated movements this is much more difficult. An example is shown in image above which
describes the behaviour of the robot as it moves linearly at a 45 degree angle and then transitions
to an in-place rotation around the robot centre axis. The bottom right graph shows the
<a href="https://en.wikipedia.org/wiki/Instant_centre_of_rotation">instantaneous centre of rotation</a> calculated
for different combinations of two wheels. In a synchronised motion all wheels should point to the same
instantaneous centre of rotation at any given moment. If the ICR's for the different wheel pairs are
in different locations then one or more of the wheels is out of sync and likely slipping along
the ground. The graph clearly shows that in this case the drive modules are not synchronized thus
causing wheel slip.</p>
<p>One way to improve the synchronization between the drive modules is apply the movement control at
an indirect level, for instance on the robot body, and then to work out from there what the drive modules
should be doing at any that given point in time along the transition profile.</p>
<p>As with the previous approach I will use a
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/profile.py#L47">linear profile</a>
to determine the transitions between different body states. Then the transition for the
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/trajectory.py#L42">body velocities (x-velocity, y-velocity, and rotational velocity)</a>
can be determined from the start state to the end state. Once it is known what
the body motion looks like I can calculate the
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/multi_wheel_steering_controller.py#L100">states for the drive modules</a>
from the body state for all given states in the transition profile.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/serve_sim_module_flip_steering_angle.png" target="_blank">
    <img
        alt="Drive module steering angle flip"
        src="/assets/images/robotics/swerve/serve_sim_module_flip_steering_angle.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Drive module steering angle flip.
  </figcaption>
</figure>
<p>One issue with this approach is that every body state can be achieved by two different module states,
one with the wheel moving &lsquo;forward&rsquo; and one with the wheel moving 'backward'. Initially the simulation
was hard-coded to always select the &lsquo;forward&rsquo; moving state. However this leads to situations where
the steering angle is flipped 180 degrees very rapidly. This is shown in the figure where the yellow
line switches from 45 degrees (or 0.78 radians) to 225 degrees (or 3.9 radians) in two time steps, or
0.02 seconds. In real life this change in steering angle would likely not be possible because the
steering angle motor would not be capable of delivering the enormous velocities and accelerations
necessary to achieve this change.</p>
<p>To resolve this issue the simulation calculated the difference in rotation and velocity between the
current point in time and the previous point in time along the transition profile, for both the
forward and backward motions. Then <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/103b321c471ced6c8865680d1e550ab4f5893526/swerve_controller/multi_wheel_steering_controller.py#L140">general rule</a>
is to pick the smallest change in both rotation and velocity of the drive module. If that isn't
possible then we pick the one with the smallest rotation difference for no real reason other than we
have to pick something. In future work a more thorough algorithm will be implemented.</p>
<p>With all that code in place the simulation delivers a much smoother result for the transition from
a 45 degree linear motion into a in-place rotation. The ICR path for all the wheel pairs is
following a single path indicating that all the drive modules are all synchronised during the
movement transition.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_body_first_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation with a body first control algorithm"
        src="/assets/images/robotics/swerve/swerve_sim_body_first_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>
    Simulation data for a 45 degree linear track that transitions to an in-place rotation with a
    body-first control algorithm.
  </figcaption>
</figure>
<p>The body oriented control approach ensures synchronisation of the drive modules while allowing
nearly all the different motions a swerve drive can make. The only motions not possible are those
that involve drive module steering angle changes only.</p>
<p>The next improvement will be to replace the linear interpolation between the start state and the
desired end state with a control approach that will provide
<a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">smooth transitions</a> for velocity and
accelerations. This will make the motions of the robot less jerky and thus less likely to damage
parts while also providing a smoother ride for the payload.</p>
<h4>Edits</h4>
<ul>
<li>July 4th 2023: Changed the term <code>control trajectory</code> to <code>control profile</code> because the term
<code>trajectory</code> is generally reserved for path planning situations.</li>
<li>July 4th 2023: Changed the term <code>ICR trajectory</code> to <code>ICR path</code> because the the ICR does not
follow a trajectory, it follows a path.</li>
</ul>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-kinematics-verification">Swerve drive - Verification of the kinematics solution</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Thursday, May 4, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>As I explained in an <a href="posts/Swerve-drive-kinematics-simulation">earlier post</a> I have written some
code to simulate the movement of a four wheel swerve drive.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/swerve/swerve-dof.png" target="_blank">
    <img alt="Swerve drive degrees of freedom" src="/assets/images/robotics/swerve/swerve-dof.png" />
  </a>
  <figcaption>Degrees of freedom for a swerve drive system.</figcaption>
</figure>
<p>Currently I have only implemented a
<a href="https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-steering-swerve/107383">simple kinematics based approach</a>.
This approach is based on the diagram displaying degrees of freedom for the swerve drive as well as
the coordinate systems for the different parts. The simple kinematics approach makes a number of
assumptions which greatly simplify the problem space.</p>
<ul>
<li>The steering axis of a drive module is vertical and passes through the centre of the wheel, i.e.
no positional changes occur when the wheel steering angle changes.</li>
<li>The robot is moving on a flat, horizontal surface, i.e. the contact point between the wheel and
the ground is always inline with the steering axis of a drive module.</li>
<li>The robot has no suspension, i.e. the body doesn't move vertically relative to the contact
point between the wheel and the ground.</li>
<li>There is no wheel slip.</li>
<li>There is no wheel lift-off, i.e. the wheels of the robot are always in contact with the ground.</li>
<li>The motors are infinitely powerful and fast, i.e. there are no limits on the motor performance.</li>
</ul>
<p>With diagram and the given assumptions we can derive the equations for the wheel velocity
and the steering angle of each drive module.</p>
<pre><code>v_i = v + W x r_i

alpha_i = acos (v_i_x / |v_i|)
      = asin (v_i_y / |v_i|)
</code></pre>
<p>Where</p>
<ul>
<li><code>v_i</code> - the wheel velocity of the i-th drive module, i.e. the velocity at which the drive module
would move forward if there is no wheel slip. The <code>x</code> and <code>y</code> components of this vector are
named as <code>v_i_x</code> and <code>v_i_y</code>.</li>
<li><code>v</code> - the linear velocity of the robot.</li>
<li><code>W</code> - the angular velocity of the robot.</li>
<li><code>r_i</code> - the position vector of the i-th drive module.</li>
<li><code>alpha_i</code> - the steering angle of the i-th drive module relative to the robot coordinate system.</li>
</ul>
<p>Based on these equations we can determine the forward kinematics, which translates the movement
of the drive modules to the movement of the robot body, and the inverse kinematics, which translates
the movement of the robot body to the movement of the drive modules. When doing the calculations for
a four wheel swerve drive it is important to note that the forward kinematics calculations are
<a href="https://en.wikipedia.org/wiki/Overdetermined_system">overdetermined</a>, i.e. there are more control
variables than there are outputs. This means that there are additional control variables that we can
play with. One obvious one for a swerve drive is that we can control the orientation of the robot body
independent[*] from the direction of movement of the robot. This also means that the forward kinematics
calculations are based on the <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">pseudoinverse</a>
approach which computes a best fit, a.k.a. least squares, using the drive module wheel velocities and
steering angles. In order words the wheel velocities and steering angles are approximations, not exact
values.</p>
<p>The transition between states, i.e. from one combination of x-velocity, y-velocity and rotation velocity
to another combination, is done by assuming that there is linear control for the drive module variables,
i.e. wheel velocity and steering angle. While linear control profiles are not the best control
method it does allow later on only changing the profile code to use a more suitable one, for
instance a <a href="https://en.wikipedia.org/wiki/Jerk_(physics)#In_motion_control">jerk limited</a> profile.</p>
<p>The code I wrote gives me a graphs like the ones presented in my <a href="posts/Swerve-drive-kinematics-simulation">previous post</a>.
However before I use this code to test new control algorithms I want to make sure my code is
actually producing the correct results. The <a href="https://en.wikipedia.org/wiki/Software_verification_and_validation">verification</a>
is done by running a bunch of simple simulations for which I am able to predict the behaviour using
some simple maths.</p>
<p>To verify that my code is correct I a ran a number of sets of simulations. The
<a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/linear_with_single_axis/README.md">first set</a>
is used to ensure that both the positive and the negative direction behaviour for the main axis directions.
Any differences in behaviour between the positive and the negative direction point to issues in the
simulation code. So the simulations that were done for this verification set are:</p>
<ul>
<li>Drive the robot in x-direction while facing in the x-direction, one simulation going forward from
the origin and one simulation going backwards from the origin.</li>
<li>Drive the robot in the y-direction while facing in the x-direction, one simulation going left from
the origin and one simulation going right from the origin.</li>
<li>Drive the robot in a rotation only movement, one simulation going clockwise and one simulation going
counter-clockwise.</li>
</ul>
<p>The <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/rotation_with_single_axis/README.md">second simulation set</a>
is designed to verify the coordinate calculations related to rotations. The
simulations that were done for this verification set are:</p>
<ul>
<li>Rotate the robot by 90 degrees and then drive it in the robot x-direction, driving forwards
and backwards.</li>
<li>Rotate the robot by 90 degrees and then drive it in the robot y-direction, driving left and right.</li>
</ul>
<figure style="float:right">
  <a href="/assets/images/robotics/swerve/swerve_sim_circle.png" target="_blank">
    <img
        alt="Drive the robot in a circle."
        src="/assets/images/robotics/swerve/swerve_sim_circle.png"
        width="833"
        height="800"/>
  </a>
  <figcaption>Swerve drive position and velocities for driving in a circle.</figcaption>
</figure>
<p>The <a href="https://github.com/pvandervelde/basic-swerve-sim/blob/master/verification/linear_module_first/simple_4w_steering/combined/README.md">third set of simulations</a>
is designed to verify the behaviour during combined movements. The
simulations that were done for this verification set are:</p>
<ul>
<li>Drive the robot on the 30 degree diagonals (30 degrees, 60 degrees, 120 degrees, 150 degrees),
while facing in the x-direction, one simulation going forwards from the origin and one going
backwards from the origin.</li>
<li>Drive the robot in a circle around a centre point outside the robot body.</li>
</ul>
<p>While running the verification sets a number of bugs were found and fixed. At the end of the process
all the validations passed indicating that the simulation code is usable.</p>
<p>With all of this done it is now time to do some more complicated simulations both for robot behaviour
that is specific to swerve drive systems and for different control algorithms. More on that in the next
post.</p>
<p>&ndash;</p>
<p>[*] Mostly independent. In reality the motors used in the drive modules will have
limits on how fast they can be driven, how much torque they can produce and
how fast they can change from one state to the next. This means that there
are limitations on movements of the drive modules and thus the robot body. For
instance if a drive module has a maximum linear velocity of 1.0 m/s it is
not possible to drive the robot diagonally any faster than this velocity, even
though we can drive the robot in x-direction at 1.0 m/s and we can drive the
robot in y-direction at 1.0 m/s. We just can't do both at the same time.</p>
<h4>Edits</h4>
<ul>
<li>July 4th 2023: Changed the term <code>control trajectory</code> to <code>control profile</code> because the term
<code>trajectory</code> is generally reserved for path planning situations.</li>
</ul>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-kinematics-simulation">Swerve drive - Kinematics simulation</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Friday, February 10, 2023
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Kinematics" class="btn btn-default btn-xs tag-no-wrap">Kinematics</a>
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>As <a href="posts/Swerve-drive-introduction">mentioned</a> I am designing and building four wheel steering
mobile robot for use in outdoor environments and rough terrain. In that post I mused that both
the mechanical design and the software would be the most complicated parts of the drive system and
thus the parts I should focus on first. At the moment I don't have good access to a workshop where I
can experiment with the mechanical design so for now I'm focussing on the creation of the control
software. Once I have the controller software working I can then use Gazebo to test the robot
virtually to ensure that the code will work in the actual robot.</p>
<p>Unlike a differential drive a four wheel swerve drive has more degrees of freedom than needed, eight
degrees of freedom (steering angle and wheel velocity for each drive module) for the control versus
three spatial degrees of freedom (forward, sideways and rotate). This means that a swerve drive is
an over-determined system, requiring the control system to carefully control the wheel velocities
and angles so that they agree with each other, otherwise the wheels slip or drag.</p>
<figure style="float:left">
  <a href="/assets/images/robotics/swerve/swerve-dof.png" target="_blank">
    <img alt="Swerve drive degrees of freedom" src="/assets/images/robotics/swerve/swerve-dof.png" />
  </a>
  <figcaption>Degrees of freedom for a swerve drive system.</figcaption>
</figure>
<p>While doing some research I found many
<a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=multi+wheel+steering&amp;btnG=">different</a>
<a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0,5&amp;q=multi+wheel+steering+icr+mobile+robots">scientific</a>
<a href="https://scholar.google.com/citations?hl=en&amp;user=H10kxZgAAAAJ&amp;view_op=list_works&amp;sortby=pubdate">papers</a>
describing algorithms for determining the <a href="https://en.wikipedia.org/wiki/Forward_kinematics">forward</a>
and <a href="https://en.wikipedia.org/wiki/Inverse_kinematics">inverse</a> kinematics of a four wheel steering system.
There are however very <a href="https://github.com/MarkNaeem/ros_controllers/tree/noetic-devel/swerve_steering_controller">few</a>
<a href="https://github.com/ros-controls/ros_controllers/pull/441">software</a>
<a href="https://github.com/james-yoo/swerve_drive">libraries</a> which implement the different control algorithms.</p>
<p>Most papers and libraries focus on the simpler case of an indoor robot that moves along a flat
horizontal surface. In this case relatively simple kinematics approaches can be used. Unfortunately
these algorithms fail when used in 3d uneven terrain. A different
<a href="https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=H10kxZgAAAAJ&amp;sortby=pubdate&amp;citation_for_view=H10kxZgAAAAJ:Se3iqnhoufwC">approach</a>
is required for that case. At the moment I too will be focussed on algorithms for driving on
flat surfaces. At least until I have correctly working control code.</p>
<p>After reading a number of papers and looking at some of the available code I have come to the
conclusion that I don't understand what is required for a successful swerve algorithm. There are
many variables that influence the behaviour making it hard to visualize what goes on as the robot is
moving around. So I wrote some <a href="https://github.com/pvandervelde/basic-swerve-sim">code</a>
to simulate what is going on (roughly) in a swerve drive while it is moving and steering. I'm
going to use this code to answer a number of questions I have about the different control algorithms.</p>
<p>For instance algorithms often calculate the desired end state and then set the wheel position and
velocity to those required for that desired state. The question is does this algorithm automatically
ensure that the intermediate states are synchronised, and if not does that matter? An example of
this would be a robot moving linearly at 45 degrees and transitioning to an in-place rotation, as pictured
below. During the transition all drive modules should be synchronised so that the center of rotation
for the robot matches with the state of the drive modules.</p>
<figure style="float:right">
  <a href="/assets/images/robotics/swerve/transition-45-to-rotate.png" target="_blank">
    <img
        alt="Transition from 45 degree linear motion to in-place rotation."
        src="/assets/images/robotics/swerve/transition-45-to-rotate.png"
        width="525"
        height="385"/>
  </a>
  <figcaption>Transition from 45 degree linear motion to in-place rotation.</figcaption>
</figure>
<p>Another example is that many of the code libraries add an optimization that reverses the wheel
direction in favour of reducing the steering angle. For instance instead of changing the steering
angle from 0 degrees to 225 degrees with a wheel velocity of 1.0 rad/s, change the angle to 45 degrees
and reverse the wheel velocity to -1.0 rad/s. Again there are a number of questions about
this optimization. For instance making a smaller steering angle change reduces the energy used, however
stopping and reversing the wheel motion also takes energy, so what are the benefits of this optimization,
if any? And how do the algorithms keep the wheel motions synchronised when performing the reversing
optimization?</p>
<p>The following graphs show an example of the simulation output. The motion being simulated is that of
a robot transiting from moving at a 45 degree straight path to an in-place rotation. The graphs
display the status of the robot body, position and velocity and the status of the different drive modules,
the angular orientation and the wheel velocity. The last graph depicts the location of the
Instantaneous Centre of Rotation (ICR) for different combinations of drive modules. The ICR is the
point in space around which the robot turns. If the control algorithm is correct then the ICR points
for different drive module combinations all fall in the same location though out the entire movement
pattern.</p>
<figure style="float:middle">
  <a href="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png" target="_blank">
    <img
        alt="45 degree linear track to in-place rotation"
        src="/assets/images/robotics/swerve/swerve_sim_45_linear_to_inplace_rotation.png"
        width="840"
        height="368"/>
  </a>
  <figcaption>Simulation data for a 45 degree linear track that transitions to an in-place rotation.</figcaption>
</figure>
<p>Looking at these graphs a couple of observations can be made. The first observation is that the ICR
paths for the different module combinations don't match each other. This means that the drive modules
are not synchronised and one or more wheels will be experiencing wheel slip.
The second observation is that the linear control algorithm causes sharp changes in velocities leading
to extremely high acceleration demands. It seems unlikely that the motors and the structure would
be able to cope with these demands.</p>
<p>From this relatively simple simulation we can see that there are a number of behaviours that the
control system needs to cope with:</p>
<ul>
<li>The state of the drive modules actively needs to be kept in sync at all times, including during
transitions from one movement state to another. This indicates that dynamic control is required
and thus poses questions about the update frequency for drive module sensors and control commands.</li>
<li>The capabilities and behaviour of the motors needs to be taken into account in order to prevent
impossible movement commands and also to ensure that the drive modules remain synchronised during
movement commands that require fast state changes from the motors, e.g. to deal with motor
<a href="https://en.wikipedia.org/wiki/Deadband">deadband</a> or fast accelerations.</li>
<li>The structural and kinematic limitations need to be considered when giving and processing movement
commands.</li>
<li>Linear control behaviour is not ideal as it causes large acceleration demands so a better approach
is necessary.</li>
</ul>
<p>Now that I have some working simulation code what are the next steps? The first stage is to simulate
some more simple movement trajectories to validate the simulation code. Once I have confidence that
the code actually simulates real world behaviour I can implement different control algorithms. These
algorithms can then be compared to see which algorithm behaves the best. Currently I'm thinking to
implement</p>
<ul>
<li>A control algorithm that uses a known movement profile for the robot base. It can then calculate
the desired drive module state across time to match the robot base movement. The movement profile
could be linear, polynomial or any other sensible profile.</li>
<li>A controller that optimizes module turn time by having it turn the shortest amount and reversing
the wheel velocity if required.</li>
<li>A low <a href="https://en.wikipedia.org/wiki/Jerk_(physics)">jerk</a> controller that ensures smooth movement
of the robot body and drive modules.</li>
</ul>
<p>In future posts I will provide more details about the different controller and model algorithms.</p>

                </div>
            </div>
        </div>
        <div id="post-spacer">
            <div id="post">
                <div id="post-header">
                    <!--
    Model is: Tuple<IDocument, IDocument>.
    The first one is the current document that is being rendered, the second one is the one for which the post header should be rendered.
-->


<h2>
            <a href="/posts/Swerve-drive-introduction">Swerve drive - Moving a robot in all directions, mostly</a>
</h2>
<div id="post-meta">
    <div class="meta-date">
Sunday, December 4, 2022
 |             Posted in     </div>
    <div class="meta-tags">
                        <a id="post-category" role="button" href="/tags/Omnidirectional" class="btn btn-default btn-xs tag-no-wrap">Omnidirectional</a>
                        <a id="post-category" role="button" href="/tags/Robotics" class="btn btn-default btn-xs tag-no-wrap">Robotics</a>
                        <a id="post-category" role="button" href="/tags/Swerve" class="btn btn-default btn-xs tag-no-wrap">Swerve</a>
    </div>
</div>

                </div>
                <div id="post-content">
                    <p>Over the last year I have been using my <a href="https://www.scuttlerobot.org/">SCUTTLE robot</a> as a way of
learning about robotics and all the related fields like mechanics and electronics. A major part of
this journey is the desire to design and build an autonomous mobile robot from the ground up.</p>
<p>My goal is to build an off-road capable robot that can navigate autonomously between different
locations to execute tasks either by itself or in cooperation with other robots. This is
quite an inspirational goal that involves quite a few robot different parts, a lot
of code and many hours of building and testing to achieve.</p>
<p>The chassis of the robot will have four drive modules. Each module has one wheel attached that will
both be independently driven, and independently steerable. This configuration is called
<code>four wheel independent steering</code> or <code>swerve drive</code>. These kind of steering systems are used in
<a href="https://en.wikipedia.org/wiki/Self-propelled_modular_transporter">heavy transport</a>,
agriculture machines, <a href="https://en.wikipedia.org/wiki/Curiosity_(rover)">mars rovers</a> and
<a href="https://www.chiefdelphi.com/t/best-frc-swerve-drive/399865">robot competitions</a>. The advantages of
a swerve drive system are that:</p>
<ul>
<li>It provides a high degree of mobility. In a swerve drive direction of movement and orientation
are independent so the robot can face forwards while driving sideways. Additionally in a swerve drive
the <a href="https://en.wikipedia.org/wiki/Instant_centre_of_rotation#:%7E:text=The%20instant%20center%20of%20rotation,a%20particular%20instant%20of%20time.">Instantaneous Center of Rotation (ICR)</a>
is not fixed to a specific line as it is with <a href="https://en.wikipedia.org/wiki/Ackermann_steering_geometry">Ackermann steering</a>
or <a href="https://en.wikipedia.org/wiki/Differential_wheeled_robot">differential drive</a>. This flexibility
allows the swerve drive to combine rotational movements with linear movements in ways that
other drive systems cannot.</li>
<li>It has normal size wheels which provide a high carry capacity. While
<a href="https://en.wikipedia.org/wiki/Omni_wheel">omni-wheels</a> have the similar degree of freedom as a
swerve drive does, omni-wheels can often not carry the same load due to the lower carrying
capacity of the rollers that allow the omni-wheels to move sideways.</li>
<li>It doesn't rely on wheel slip, as multi-wheel differential drive does. This means that it has
lower power demands, so more of the motor torque can be used to move the robot forward.</li>
<li>It has the ability to traverse rough and dirty terrain due to the fact that all wheels are
driven as well as using normal wheels on each drive module. Omni-wheels and <a href="https://en.wikipedia.org/wiki/Mecanum_wheel">mecanum wheels</a>
face more issues in these environments due to dust and dirt clogging up the wheels as well as
having greater difficulty tackling obstacles.</li>
<li>It is able to keep ground disturbance to a minimum as it is able to steer the robot while minimizing
sliding movement. Other drive systems, e.g. tracks or multi-axle differential drives, have a bigger
impact due to the sliding movement required for these systems to turn the robot.</li>
</ul>
<p>Of course the swerve drive system isn't a magical system that only has advantages. There are also plenty
of disadvantages. For instance swerve drive systems:</p>
<ul>
<li>Are mechanically complicated. They require multiple motors per unit and multiple units per robot.
On top of that there are usually a number of mechanical components, gears and bearings, involved
in getting a working swerve drive.</li>
<li>Need a complicated control system. Swerve systems are generally
over-determined, i.e. they have more degrees of freedom in the drive system, 2 per drive module,
than there are degrees of freedom in the robot, 2 translation directions and a rotation. This
means that all modules have to be synchronised at all times in order to prevent wheels from being
dragged along. The available degrees of freedom combined with the synchronisation demand means some
complicated math is required to make a swerve drive control work.</li>
<li>Similar to the control side of the drive determining the position and velocity of the robot using
wheel <a href="https://en.wikipedia.org/wiki/Odometry">odometry</a> requires more complicated math. This is
due to the fact that the different drive modules don't necessarily agree with each other.</li>
<li>Have more failure modes than other drive systems due to the fact that there are more moving parts.</li>
</ul>
<p>So with all these complications why would I try to build a swerve drive as my second robot and not
a differential drive robot or something similar. As pointed out previously there are good
reasons to use a swerve drive in an outdoor environment, i.e. high agility, good load capacity,
traction from all wheels, low ground impact. However the main reason I want to design and build a
swerve drive is because it is a challenge. Swerve drives are complicated and designing and building
one involves solving interesting problems in mechanical engineering, electrical engineering and
software engineering.</p>
<p>There is currently no complete design for this robot yet, however there is a short list of design
decisions that have been made so far.</p>
<ul>
<li>It will be a four wheel swerve drive robot. Swerve drives have been built with anything from
three wheels up, e.g. the Curiosity mars rover has 6 drive modules. The reason to use four modules
is that it will be symmetrical and still minimize the number of parts necessary.</li>
<li>The software for the robot will be using <a href="https://docs.ros.org/en/humble/index.html">ROS2 Humble</a>.
Using ROS should provide me with a base framework and a lot of standard capabilities, like the
navigation stack, that I won't have to write myself. Additionally ROS has a decent simulation
environment that will allow me to test my code before putting it on a real robot.</li>
<li>The hardware will be controlled using <a href="https://control.ros.org/master/index.html">ROS2 controllers</a>.
This will allow me to abstract the hardware so that I can better test the controller.</li>
<li>The initial design will be an indoor model and about the same size as my SCUTTLE robot is. This will
simplify the initial design and allow me to compare with SCUTTLE.</li>
</ul>
<p>The parts of the robot that I expect to be complicated and quite possibly show stoppers are the
software and the mechanical design. For the software the drive controller software, which translates
the requested velocity commands to motor commands for both the drive and steering motors, will be
complicated as it needs to make sure that all drive modules are the correct state. This piece of
software also needs to handle all the error conditions that occur.</p>
<p>On the mechanical side I need to design the drive module such that it can drive the wheel forwards
and backwards while allowing &lsquo;infinite&rsquo; steering rotation. This will require a co-axial setup and a
bit of gearing. The second complicated part of the mechanical design is the inclusion of a suspension
system. Ideally the motors should be attached to the sprung side of the suspension system so that
they don't get exposed to excessive vibration. This however will complicate the mechanical design.</p>
<iframe
    style="float:left"
    width="560"
    height="315"
    src="https://www.youtube.com/embed/fR47Y7p4mtQ"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe>
<p>My plan is to work on the control software first. I can test that software using simulation and so
figure out if I can even make it work. I have created a simple URDF model that uses
ROS2 controllers to simulate a four wheel steering platform. This allowed me to learn more about
ROS2, ROS2 controls and how the interaction of those two with Gazebo works.</p>
<p>At the moment I'm implementing a prototype for the controller in python so that I can use the model to
test if my algorithm works before I turn it into a proper ROS2 controller, which will need to be
written in C++.</p>
<p>Once I have some kind of controlling software I am aiming to build a single drive module with a drive
motor, a steering motor and the mechanical assembly that allows a single wheel to be steered and driven.
I will use this module to work out both the details on the mechanical and software sides of the project.</p>
<p>Once I have the controller and the drive module working properly I will build a simple robot, similar
in size to my SCUTTLE robot to further work on swerve drives. It will take me a little while
to get to that state though. In the mean time I will keep working on my design and documenting my
journey.</p>

                </div>
            </div>
        </div>
            </div>
        </div>

        <footer>
            <div id="footer" class="container">
    <div id="fbox1">
        <h2>Related</h2>
        <ul>
            <li><a href="https://github.com/pvandervelde"><i class="fa fa-github"></i> GitHub</a></li>
            <li><a href="https://www.linkedin.com/profile/view?id=33950311"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
            <li><a href="https://stackoverflow.com/users/539846/petrik"><i class="fa fa-stack-overflow"></i> StackOverflow</a></li>
            <li><a href="https://careers.stackoverflow.com/pvandervelde"><i class="fa fa-stack-overflow"></i> StackOverflow Careers</a></li>
            <li><a href="https://profile.codersrank.io/user/pvandervelde">CodersRank</a></li>
        </ul>
    </div>
    <div id="fbox2">
        <h2 id="copyright">Copyright</h2>
        <p>Copyright (c) 2023 <a href="/">Petrik van der Velde</a>. All rights reserved.</p>

        <h2 id="disclaimer">Disclaimer</h2>
        <p>The opinions expressed herein are my own personal opinions and do not represent my employer's view in any way.</p>
    </div>
    <div id="fbox3">
        <h2 id="media">Media</h2>
        <p><a href="/feed.atom"><img src="/assets/images/feed.png" alt="Atom feed"></a></p>
    </div>
</div>
<div id="copyright" class="container">
    <div>
        <p>
            Generated by <a href="https://wyam.io">Wyam</a> on Thu, 06 Jul 2023 11:06:41 GMT

 from commit <a href="https://github.com/pvandervelde/mindvortex/tree/a2b130ee5509ab6a6593a4aadb7cada1f5fa30c1">a2b130ee5509ab6a6593a4aadb7cada1f5fa30c1</a> at version 3.16.1.        </p>
    </div>

    <p>
        Site design based on the <a href="https://www.freecsstemplates.org/previews/opentools/">Open Tools</a> design
        by <a href="https://www.freecsstemplates.org">FreeCSSTemplates.org</a>.
    </p>
    <p>
        Feed icon by <a href="https://www.icojam.com/">Icojam</a> and Favicon by
        <a href="https://www.flaticon.com/free-icon/twister-sky-wind_12318" title="Yannick">Yannick</a>
        from <a href="https://www.flaticon.com" title="Flaticon">www.flaticon.com</a>
    </p>
</div>

        </footer>
    </body>
</html>
